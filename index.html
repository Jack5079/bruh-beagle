<!-- 
    You've peeked inside the source code for a Wick project... you are clever!

    This file was generated by the WickProject exporter. 
    (see src/editor/WickProject.Exporter.js) at https://github.com/zrispo/wick/ 

    Send any questions to https://twitter.com/zrispo !!!
 -->

<head>
    <style>
        /* remove the top and left whitespace */
    	* { margin:0; padding:0; }

        /* just to be sure these are full screen */
    	html, body { width:100%; height:100%; background-color: #FFFFFF; }

        /* To remove the scrollbars */
    	canvas { display:block; }

        canvas:focus {
            outline: none;
            outline-style: none;
        }

        /* Cross browser cursor hide class */
        .hideCursor {
            cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg=='),
            none !important;
        }
    </style>
</head>

<script>wickEditor = null;</script>

<body>
	<div id="playerCanvasContainer" readonly="readonly"></div>
</body>


<script src="pixi.js"></script>
<script>/*
 * Copyright 2016 Small Batch, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/* Web Font Loader v1.6.26 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.m=b||a;this.c=this.m.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function z(a){if("string"===typeof a.f)return a.f;var b=a.m.location.protocol;"about:"==b&&(b=a.a.location.protocol);return"https:"==b?"https:":"http:"}function ea(a){return a.m.location.hostname||a.a.location.hostname}
function A(a,b,c){function d(){k&&e&&f&&(k(g),k=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,k=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function B(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function C(){this.a=0;this.c=null}function D(a){a.a++;return function(){a.a--;E(a)}}function F(a,b){a.c=b;E(a)}function E(a){0==a.a&&a.c&&(a.c(),a.c=null)};function G(a){this.a=a||"-"}G.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function H(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return I(a)+" "+(a.f+"00")+" 300px "+J(a.c)}function J(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function K(a){return a.a+a.f}function I(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.m.document.documentElement;this.h=b;this.a=new G("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);L(a,"loading")}function M(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}L(a,"inactive")}function L(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,K(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function N(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function O(a){u(a.c,"body",a.a)}function P(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+J(a.c)+";"+("font-style:"+I(a)+";font-weight:"+(a.f+"00")+";")};function Q(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}Q.prototype.start=function(){var a=this.c.m.document,b=this,c=q(),d=new Promise(function(d,e){function k(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(k,25)},function(){e()})}k()}),e=new Promise(function(a,d){setTimeout(d,b.f)});Promise.race([e,d]).then(function(){b.g(b.a)},function(){b.j(b.a)})};function R(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.o=this.j=this.h=this.g=null;this.g=new N(this.c,this.s);this.h=new N(this.c,this.s);this.j=new N(this.c,this.s);this.o=new N(this.c,this.s);a=new H(this.a.c+",serif",K(this.a));a=P(a);this.g.a.style.cssText=a;a=new H(this.a.c+",sans-serif",K(this.a));a=P(a);this.h.a.style.cssText=a;a=new H("serif",K(this.a));a=P(a);this.j.a.style.cssText=a;a=new H("sans-serif",K(this.a));a=
P(a);this.o.a.style.cssText=a;O(this.g);O(this.h);O(this.j);O(this.o)}var S={D:"serif",C:"sans-serif"},T=null;function U(){if(null===T){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);T=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return T}R.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.o.a.offsetWidth;this.A=q();la(this)};
function ma(a,b,c){for(var d in S)if(S.hasOwnProperty(d)&&b===a.f[S[d]]&&c===a.f[S[d]])return!0;return!1}function la(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=U()&&ma(a,b,c));d?q()-a.A>=a.w?U()&&ma(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):na(a):V(a,a.v)}function na(a){setTimeout(p(function(){la(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.o=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,K(a).toString(),"active")],[b.a.c("wf",a.c,K(a).toString(),"loading"),b.a.c("wf",a.c,K(a).toString(),"inactive")]);L(b,"fontactive",a);this.o=!0;oa(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,K(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,K(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,K(a).toString(),"inactive"));w(b.f,d,e)}L(b,"fontinactive",a);oa(this)};function oa(a){0==--a.f&&a.j&&(a.o?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),L(a,"active")):M(a.a))};function pa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}pa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;qa(this,new ha(this.c,a),a)};
function ra(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,k=d||null||{};if(0===c.length&&f)M(b.a);else{b.f+=c.length;f&&(b.j=f);var h,m=[];for(h=0;h<c.length;h++){var l=c[h],n=k[l.c],r=b.a,x=l;r.g&&w(r.f,[r.a.c("wf",x.c,K(x).toString(),"loading")]);L(r,"fontloading",x);r=null;null===X&&(X=window.FontFace?(x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent))?42<parseInt(x[1],10):!0:!1);X?r=new Q(p(b.g,b),p(b.h,b),b.c,l,b.s,n):r=new R(p(b.g,b),p(b.h,b),b.c,l,b.s,a,
n);m.push(r)}for(h=0;h<m.length;h++)m[h].start()}},0)}function qa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){ra(a,f,b,d,c)})};function sa(a,b){this.c=a;this.a=b}function ta(a,b,c){var d=z(a.c);a=(a.a.api||"fast.fonts.net/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return d+"//"+a+"/"+b+".js"+(c?"?v="+c:"")}
sa.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var m=0;m<c.length;m++){var l=c[m].fontfamily;void 0!=c[m].fontStyle&&void 0!=c[m].fontWeight?(h=c[m].fontStyle+c[m].fontWeight,e.push(new H(l,h))):e.push(new H(l))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.m;B(this.c,ta(c,d,e),function(e){e?a([]):(f["__MonotypeConfiguration__"+d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+
d}else a([])};function ua(a,b){this.c=a;this.a=b}ua.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new C;b=0;for(c=d.length;b<c;b++)A(this.c,d[b],D(g));var k=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),m=0;m<h.length;m+=1)k.push(new H(d[0],h[m]));else k.push(new H(d[0]));F(g,function(){a(k,f)})};function va(a,b,c){a?this.c=a:this.c=b+wa;this.a=[];this.f=[];this.g=c||""}var wa="//fonts.googleapis.com/css";function xa(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function ya(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function za(a){this.f=a;this.a=[];this.c={}}
var Aa={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Ba={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ca={i:"i",italic:"i",n:"n",normal:"n"},
Da=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Ea(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var k=d[1];g=[];if(k)for(var k=k.split(","),h=k.length,m=0;m<h;m++){var l;l=k[m];if(l.match(/^[\w-]+$/)){var n=Da.exec(l.toLowerCase());if(null==n)l="";else{l=n[2];l=null==l||""==l?"n":Ca[l];n=n[1];if(null==n||""==n)n="4";else var r=Ba[n],n=r?r:isNaN(n)?"4":n.substr(0,1);l=[l,n].join("")}}else l="";l&&g.push(l)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=Aa[d[0]])&&(a.c[e]=d))}a.c[e]||(d=Aa[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new H(e,f[d]))}};function Fa(a,b){this.c=a;this.a=b}var Ga={Arimo:!0,Cousine:!0,Tinos:!0};Fa.prototype.load=function(a){var b=new C,c=this.c,d=new va(this.a.api,z(c),this.a.text),e=this.a.families;xa(d,e);var f=new za(e);Ea(f);A(c,ya(d),D(b));F(b,function(){a(f.a,f.c,Ga)})};function Ha(a,b){this.c=a;this.a=b}Ha.prototype.load=function(a){var b=this.a.id,c=this.c.m;b?B(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],k=b[f+1],h=0;h<k.length;h++)e.push(new H(g,k[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(m){}a(e)}},2E3):a([])};function Ia(a,b){this.c=a;this.f=b;this.a=[]}Ia.prototype.load=function(a){var b=this.f.id,c=this.c.m,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,k=c.fonts.length;g<k;++g){var h=c.fonts[g];d.a.push(new H(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},B(this.c,z(this.c)+(this.f.api||"//f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new pa(window);Y.a.c.custom=function(a,b){return new ua(b,a)};Y.a.c.fontdeck=function(a,b){return new Ia(b,a)};Y.a.c.monotype=function(a,b){return new sa(b,a)};Y.a.c.typekit=function(a,b){return new Ha(b,a)};Y.a.c.google=function(a,b){return new Fa(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());
</script>
<script>var LZString=function(){function o(o,r){if(!t[o]){t[o]={};for(var n=0;n<o.length;n++)t[o][o.charAt(n)]=n}return t[o][r]}var r=String.fromCharCode,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",t={},i={compressToBase64:function(o){if(null==o)return"";var r=i._compress(o,6,function(o){return n.charAt(o)});switch(r.length%4){default:case 0:return r;case 1:return r+"===";case 2:return r+"==";case 3:return r+"="}},decompressFromBase64:function(r){return null==r?"":""==r?null:i._decompress(r.length,32,function(e){return o(n,r.charAt(e))})},compressToUTF16:function(o){return null==o?"":i._compress(o,15,function(o){return r(o+32)})+" "},decompressFromUTF16:function(o){return null==o?"":""==o?null:i._decompress(o.length,16384,function(r){return o.charCodeAt(r)-32})},compressToUint8Array:function(o){for(var r=i.compress(o),n=new Uint8Array(2*r.length),e=0,t=r.length;t>e;e++){var s=r.charCodeAt(e);n[2*e]=s>>>8,n[2*e+1]=s%256}return n},decompressFromUint8Array:function(o){if(null===o||void 0===o)return i.decompress(o);for(var n=new Array(o.length/2),e=0,t=n.length;t>e;e++)n[e]=256*o[2*e]+o[2*e+1];var s=[];return n.forEach(function(o){s.push(r(o))}),i.decompress(s.join(""))},compressToEncodedURIComponent:function(o){return null==o?"":i._compress(o,6,function(o){return e.charAt(o)})},decompressFromEncodedURIComponent:function(r){return null==r?"":""==r?null:(r=r.replace(/ /g,"+"),i._decompress(r.length,32,function(n){return o(e,r.charAt(n))}))},compress:function(o){return i._compress(o,16,function(o){return r(o)})},_compress:function(o,r,n){if(null==o)return"";var e,t,i,s={},p={},u="",c="",a="",l=2,f=3,h=2,d=[],m=0,v=0;for(i=0;i<o.length;i+=1)if(u=o.charAt(i),Object.prototype.hasOwnProperty.call(s,u)||(s[u]=f++,p[u]=!0),c=a+u,Object.prototype.hasOwnProperty.call(s,c))a=c;else{if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++),s[c]=f++,a=String(u)}if(""!==a){if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++)}for(t=2,e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;for(;;){if(m<<=1,v==r-1){d.push(n(m));break}v++}return d.join("")},decompress:function(o){return null==o?"":""==o?null:i._decompress(o.length,32768,function(r){return o.charCodeAt(r)})},_decompress:function(o,n,e){var t,i,s,p,u,c,a,l,f=[],h=4,d=4,m=3,v="",w=[],A={val:e(0),position:n,index:1};for(i=0;3>i;i+=1)f[i]=i;for(p=0,c=Math.pow(2,2),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(t=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=r(p);break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=r(p);break;case 2:return""}for(f[3]=l,s=l,w.push(l);;){if(A.index>o)return"";for(p=0,c=Math.pow(2,m),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(l=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=r(p),l=d-1,h--;break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=r(p),l=d-1,h--;break;case 2:return w.join("")}if(0==h&&(h=Math.pow(2,m),m++),f[l])v=f[l];else{if(l!==d)return null;v=s+s.charAt(0)}w.push(v),f[d++]=s+v.charAt(0),h--,s=v,0==h&&(h=Math.pow(2,m),m++)}}};return i}();"function"==typeof define&&define.amd?define(function(){return LZString}):"undefined"!=typeof module&&null!=module&&(module.exports=LZString);
</script>
<script>if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position){
      position = position || 0;
      return this.substr(position, searchString.length) === searchString;
  };
}

if (!Object.keys) {
    Object.keys = function (obj) {
        var keys = [],
            k;
        for (k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
            }
        }
        return keys;
    };
}

// http://stackoverflow.com/questions/872310/javascript-swap-array-elements
Array.prototype.swap = function (x,y) {
  var b = this[x];
  this[x] = this[y];
  this[y] = b;
  return this;
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEachBackwards) {

  Array.prototype.forEachBackwards = function(callback, thisArg) {

    var T, k;

    if (this === null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = len-1;

    // 7. Repeat, while k < len
    while (k >= 0) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k--;
    }
    // 8. return undefined
  };
}

//http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
// Warn if overriding existing method
if(Array.prototype.equals)
    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time 
    if (this.length != array.length)
        return false;

    for (var i = 0, l=this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;       
        }           
        else if (this[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;   
        }           
    }       
    return true;
}
// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {enumerable: false});

//if(!BrowserDetectionUtils.isChrome || !BrowserDetectionUtils.isFirefox) {
    window.polyfillClipboardData = (function () {
        var pcd = {};

        var data = {};
        
        pcd.types = [];

        pcd.setData = function (type,newdata) {
            data[type] = {type:type,data:newdata};
            if(pcd.types.indexOf(type) === -1) pcd.types.push(type);
        }

        pcd.getData = function (type) {
            return data[type].data;
        }

        return pcd;
    })();
//}

var BrowserDetect = (function () {

    var browserDetectionUtils = { };

    browserDetectionUtils.isFirefox = 
        navigator.userAgent.search("Firefox");

    browserDetectionUtils.isSafari = 
        navigator.appVersion.search('Safari') != -1 
     && navigator.appVersion.search('Chrome') == -1 
     && navigator.appVersion.search('CrMo') == -1 
     && navigator.appVersion.search('CriOS') == -1;

    browserDetectionUtils.isIe = (
        navigator.userAgent.toLowerCase().indexOf("msie") != -1 
     || navigator.userAgent.toLowerCase().indexOf("trident") != -1 );

    browserDetectionUtils.isChrome = 
        /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);

    browserDetectionUtils.inMobileMode =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    return browserDetectionUtils;
    
})();

//http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
Array.prototype.move = function (old_index, new_index) {
    if (new_index >= this.length) {
        var k = new_index - this.length;
        while ((k--) + 1) {
            this.push(undefined);
        }
    }
    this.splice(new_index, 0, this.splice(old_index, 1)[0]);
    return this; // for testing purposes
};

// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function(searchElement, fromIndex) {

      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      // 6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        // c. Increase k by 1.
        // NOTE: === provides the correct "SameValueZero" comparison needed here.
        if (o[k] === searchElement) {
          return true;
        }
        k++;
      }

      // 8. Return false
      return false;
    }
  });
}

var isSafari = navigator.appVersion.search('Safari') != -1 && navigator.appVersion.search('Chrome') == -1 && navigator.appVersion.search('CrMo') == -1 && navigator.appVersion.search('CriOS') == -1;
var isIe = (navigator.userAgent.toLowerCase().indexOf("msie") != -1 || navigator.userAgent.toLowerCase().indexOf("trident") != -1);
var isChrome = /chrome/.test( navigator.userAgent.toLowerCase() );

var roundToNearestN = function (val, n, d) {
  if(d === undefined) d = 20;
  return parseFloat((Math.round(val/n)*n).toFixed(d));
}

var roundToHundredths = function (val) {
  return roundToNearestN(val, 0.01, 2);
}

var buildDiv = function(className, parentElem) {
  var div = document.createElement('div');
  div.className = className;
  if(parentElem) {
    parentElem.appendChild(div);
  }
  return div;
}

var buildSpan = function(className, parentElem) {
  var div = document.createElement('span');
  div.className = className;
  if(parentElem) {
    parentElem.appendChild(div);
  }
  return div;
}

//http://stackoverflow.com/questions/11076975/insert-text-into-textarea-at-cursor-position-javascript
function insertAtCursor(myField, myValue) {
    //IE support
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    //MOZILLA and others
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
    } else {
        myField.value += myValue;
    }
}

var startMillis;
function resetElapsedTime () {
  startMillis = new Date().getTime()
}
resetElapsedTime();
function elapsedSeconds () {
  return Math.floor(elapsedMilliseconds()/1000);
}

function elapsedMilliseconds () {
  var d = new Date();
  var n = d.getTime();
  return n - startMillis;
}

function rotate_point(pointX, pointY, originX, originY, angle) {
  angle = angle * Math.PI / 180.0;
  return {
    x: Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
    y: Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
  };
}

Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
}
NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
}

// http://stackoverflow.com/questions/9705123/how-can-i-get-sin-cos-and-tan-to-use-degrees-instead-of-radians
function toRadians (angle) {
  return angle * (Math.PI / 180);
}

function clamp (val, min, max) {
  return Math.min(Math.max(val, min), max);
}


// 
function hexToRgbA(hex, a){
    var c;

    if(hex === 'none') return 'rgba(0,0,0,0)';

    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
        c= hex.substring(1).split('');
        if(c.length== 3){
            c= [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c= '0x'+c.join('');
        return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+a+')';
    }
    console.log(hex);
    throw new Error('Bad Hex');
}

function dataURItoBlob(dataURI) {
  // convert base64 to raw binary data held in a string
  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
  var byteString = atob(dataURI.split(',')[1]);

  // separate out the mime component
  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

  // write the bytes of the string to an ArrayBuffer
  var ab = new ArrayBuffer(byteString.length);
  var ia = new Uint8Array(ab);
  for (var i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
  }

  // write the ArrayBuffer to a blob, and you're done
  var blob = new Blob([ab], {type: mimeString});
  return blob;

  // Old code
  // var bb = new BlobBuilder();
  // bb.append(ab);
  // return bb.getBlob(mimeString);
}

function deepCopy (val) {
  if(typeof val === 'object') {
    return JSON.parse(JSON.stringify(val));
  } else {
    return val;
  }
}

function getAvailableFonts () {
  var availableFonts = [
    'Arial', 
    'Times New Roman', 
    'Comic Sans MS', 
    'Georgia', 
    'Palatino Linotype', 
    'Book Antiqua', 
    'Helvetica', 
    'Arial Black', 
    'Impact', 
    'Lucida Sans Unicode', 
    'Tahoma', 
    'Geneva', 
    'Trebuchet MS', 
    'Verdana', 
    'Courier New', 
    'Lucida Console'
  ];
  availableFonts.sort();
  return availableFonts;
}

function elementInsideElement (target, parent) {
  if(target === parent) return true;

  if(target.parentElement) {
    if(target.parentElement === target) {
      return true;
    } else {
      return elementInsideElement(target.parentElement, parent)
    }
  } else {
    return false;
  }
}

function getBrowserAndOSInfo () {
  var nVer = navigator.appVersion;
  var nAgt = navigator.userAgent;
  var browserName  = navigator.appName;
  var fullVersion  = ''+parseFloat(navigator.appVersion); 
  var majorVersion = parseInt(navigator.appVersion,10);
  var nameOffset,verOffset,ix;

  // In Opera, the true version is after "Opera" or after "Version"
  if ((verOffset=nAgt.indexOf("Opera"))!=-1) {
   browserName = "Opera";
   fullVersion = nAgt.substring(verOffset+6);
   if ((verOffset=nAgt.indexOf("Version"))!=-1) 
     fullVersion = nAgt.substring(verOffset+8);
  }
  // In MSIE, the true version is after "MSIE" in userAgent
  else if ((verOffset=nAgt.indexOf("MSIE"))!=-1) {
   browserName = "Microsoft Internet Explorer";
   fullVersion = nAgt.substring(verOffset+5);
  }
  // In Chrome, the true version is after "Chrome" 
  else if ((verOffset=nAgt.indexOf("Chrome"))!=-1) {
   browserName = "Chrome";
   fullVersion = nAgt.substring(verOffset+7);
  }
  // In Safari, the true version is after "Safari" or after "Version" 
  else if ((verOffset=nAgt.indexOf("Safari"))!=-1) {
   browserName = "Safari";
   fullVersion = nAgt.substring(verOffset+7);
   if ((verOffset=nAgt.indexOf("Version"))!=-1) 
     fullVersion = nAgt.substring(verOffset+8);
  }
  // In Firefox, the true version is after "Firefox" 
  else if ((verOffset=nAgt.indexOf("Firefox"))!=-1) {
   browserName = "Firefox";
   fullVersion = nAgt.substring(verOffset+8);
  }
  // In most other browsers, "name/version" is at the end of userAgent 
  else if ( (nameOffset=nAgt.lastIndexOf(' ')+1) < 
            (verOffset=nAgt.lastIndexOf('/')) ) 
  {
   browserName = nAgt.substring(nameOffset,verOffset);
   fullVersion = nAgt.substring(verOffset+1);
   if (browserName.toLowerCase()==browserName.toUpperCase()) {
    browserName = navigator.appName;
   }
  }
  // trim the fullVersion string at semicolon/space if present
  if ((ix=fullVersion.indexOf(";"))!=-1)
     fullVersion=fullVersion.substring(0,ix);
  if ((ix=fullVersion.indexOf(" "))!=-1)
     fullVersion=fullVersion.substring(0,ix);

  majorVersion = parseInt(''+fullVersion,10);
  if (isNaN(majorVersion)) {
   fullVersion  = ''+parseFloat(navigator.appVersion); 
   majorVersion = parseInt(navigator.appVersion,10);
  }

  /*return''
   +'Browser name  = '+browserName+'<br>'
   +'Full version  = '+fullVersion+'<br>'
   +'Major version = '+majorVersion+'<br>'
   +'navigator.appName = '+navigator.appName+'<br>'
   +'navigator.userAgent = '+navigator.userAgent+'<br>';*/
   return {
    browser: browserName,
    browserVersion: fullVersion,
    navigatorAppName: navigator.appName,
    navigatorUserAgent: navigator.userAgent,
    devicePixelRatio: window.devicePixelRatio,
   }

}

// https://gist.github.com/hurjas/2660489

/**
 * Return a timestamp with the format "m/d/yy h:MM:ss TT"
 * @type {Date}
 */

function timeStamp() {
// Create a date object with the current time
  var now = new Date();

  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

// Create an array with the current month, day and time
  var date = [ months[now.getMonth()], now.getDate() + '-', now.getFullYear() ];

// Create an array with the current hour, minute and second
  var time = [ now.getHours(), now.getMinutes() ];

// Determine AM or PM suffix based on the hour
  var suffix = ( time[0] < 12 ) ? "AM" : "PM";

// Convert hour from military time
  time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;

// If hour is 0, set it to 12
  time[0] = time[0] || 12;

// If seconds and minutes are less than 10, add a zero
  for ( var i = 1; i < 3; i++ ) {
    if ( time[i] < 10 ) {
      time[i] = "0" + time[i];
    }
  }

// Return the formatted string
  return date.join("") + "-" + time.join(".") + "" + suffix;
}

function invertColor(hexTripletColor) {
    var color = hexTripletColor;
    color = color.substring(1); // remove #
    color = parseInt(color, 16); // convert to integer
    color = 0xFFFFFF ^ color; // invert three bytes
    color = color.toString(16); // convert to hex
    color = ("000000" + color).slice(-6); // pad with leading zeros
    color = "#" + color; // prepend #
    return color;
}

var start;

var startTiming = function () {
  start = performance.now();
}

var stopTiming = function (name, min) {
  if(min === undefined) min = 0;
  var t = performance.now();
  var roundedT = t - start;
  if(roundedT > min) {
    console.log("SLOW: " + roundedT + "ms: " + name);
  }
  start = t
}

function previewImage (image) {
  var win = window.open('', 'Title', 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width='+image.width+', height='+image.height+', top=100, left=100');
  win.document.body.innerHTML = '<div><img src= '+image.src+'></div>';
}

function intersectRect(r1, r2) {
  return !(r2.left > r1.right || 
           r2.right < r1.left || 
           r2.top > r1.bottom ||
           r2.bottom < r1.top);
}

var GOOGLE_FONTS = [
"ABeeZee","Abel","Abhaya Libre","Abril Fatface","Aclonica","Acme","Actor","Adamina","Advent Pro","Aguafina Script","Akronim","Aladin","Aldrich","Alef","Alegreya","Alegreya SC","Alegreya Sans","Alegreya Sans SC","Alex Brush","Alfa Slab One","Alice","Alike","Alike Angular","Allan","Allerta","Allerta Stencil","Allura","Almendra","Almendra Display","Almendra SC","Amarante","Amaranth","Amatic SC","Amatica SC","Amethysta","Amiko","Amiri","Amita","Anaheim","Andada","Andika","Angkor","Annie Use Your Telescope","Anonymous Pro","Antic","Antic Didone","Antic Slab","Anton","Arapey","Arbutus","Arbutus Slab","Architects Daughter","Archivo","Archivo Black","Archivo Narrow","Aref Ruqaa","Arima Madurai","Arimo","Arizonia","Armata","Arsenal","Artifika","Arvo","Arya","Asap","Asap Condensed","Asar","Asset","Assistant","Astloch","Asul","Athiti","Atma","Atomic Age","Aubrey","Audiowide","Autour One","Average","Average Sans","Averia Gruesa Libre","Averia Libre","Averia Sans Libre","Averia Serif Libre","Bad Script","Bahiana","Baloo","Baloo Bhai","Baloo Bhaijaan","Baloo Bhaina","Baloo Chettan","Baloo Da","Baloo Paaji","Baloo Tamma","Baloo Tammudu","Baloo Thambi","Balthazar","Bangers","Barrio","Basic","Battambang","Baumans","Bayon","Belgrano","Bellefair","Belleza","BenchNine","Bentham","Berkshire Swash","Bevan","Bigelow Rules","Bigshot One","Bilbo","Bilbo Swash Caps","BioRhyme","BioRhyme Expanded","Biryani","Bitter","Black Ops One","Bokor","Bonbon","Boogaloo","Bowlby One","Bowlby One SC","Brawler","Bree Serif","Bubblegum Sans","Bubbler One","Buda","Buenard","Bungee","Bungee Hairline","Bungee Inline","Bungee Outline","Bungee Shade","Butcherman","Butterfly Kids","Cabin","Cabin Condensed","Cabin Sketch","Caesar Dressing","Cagliostro","Cairo","Calligraffitti","Cambay","Cambo","Candal","Cantarell","Cantata One","Cantora One","Capriola","Cardo","Carme","Carrois Gothic","Carrois Gothic SC","Carter One","Catamaran","Caudex","Caveat","Caveat Brush","Cedarville Cursive","Ceviche One","Changa","Changa One","Chango","Chathura","Chau Philomene One","Chela One","Chelsea Market","Chenla","Cherry Cream Soda","Cherry Swash","Chewy","Chicle","Chivo","Chonburi","Cinzel","Cinzel Decorative","Clicker Script","Coda","Coda Caption","Codystar","Coiny","Combo","Comfortaa","Coming Soon","Concert One","Condiment","Content","Contrail One","Convergence","Cookie","Copse","Corben","Cormorant","Cormorant Garamond","Cormorant Infant","Cormorant SC","Cormorant Unicase","Cormorant Upright","Courgette","Cousine","Coustard","Covered By Your Grace","Crafty Girls","Creepster","Crete Round","Crimson Text","Croissant One","Crushed","Cuprum","Cutive","Cutive Mono","Damion","Dancing Script","Dangrek","David Libre","Dawning of a New Day","Days One","Dekko","Delius","Delius Swash Caps","Delius Unicase","Della Respira","Denk One","Devonshire","Dhurjati","Didact Gothic","Diplomata","Diplomata SC","Domine","Donegal One","Doppio One","Dorsa","Dosis","Dr Sugiyama","Droid Sans","Droid Sans Mono","Droid Serif","Duru Sans","Dynalight","EB Garamond","Eagle Lake","Eater","Economica","Eczar","El Messiri","Electrolize","Elsie","Elsie Swash Caps","Emblema One","Emilys Candy","Encode Sans","Encode Sans Condensed","Encode Sans Expanded","Encode Sans Semi Condensed","Encode Sans Semi Expanded","Engagement","Englebert","Enriqueta","Erica One","Esteban","Euphoria Script","Ewert","Exo","Exo 2","Expletus Sans","Fanwood Text","Farsan","Fascinate","Fascinate Inline","Faster One","Fasthand","Fauna One","Faustina","Federant","Federo","Felipa","Fenix","Finger Paint","Fira Mono","Fira Sans","Fira Sans Condensed","Fira Sans Extra Condensed","Fjalla One","Fjord One","Flamenco","Flavors","Fondamento","Fontdiner Swanky","Forum","Francois One","Frank Ruhl Libre","Freckle Face","Fredericka the Great","Fredoka One","Freehand","Fresca","Frijole","Fruktur","Fugaz One","GFS Didot","GFS Neohellenic","Gabriela","Gafata","Galada","Galdeano","Galindo","Gentium Basic","Gentium Book Basic","Geo","Geostar","Geostar Fill","Germania One","Gidugu","Gilda Display","Give You Glory","Glass Antiqua","Glegoo","Gloria Hallelujah","Goblin One","Gochi Hand","Gorditas","Goudy Bookletter 1911","Graduate","Grand Hotel","Gravitas One","Great Vibes","Griffy","Gruppo","Gudea","Gurajada","Habibi","Halant","Hammersmith One","Hanalei","Hanalei Fill","Handlee","Hanuman","Happy Monkey","Harmattan","Headland One","Heebo","Henny Penny","Herr Von Muellerhoff","Hind","Hind Guntur","Hind Madurai","Hind Siliguri","Hind Vadodara","Holtwood One SC","Homemade Apple","Homenaje","IM Fell DW Pica","IM Fell DW Pica SC","IM Fell Double Pica","IM Fell Double Pica SC","IM Fell English","IM Fell English SC","IM Fell French Canon","IM Fell French Canon SC","IM Fell Great Primer","IM Fell Great Primer SC","Iceberg","Iceland","Imprima","Inconsolata","Inder","Indie Flower","Inika","Inknut Antiqua","Irish Grover","Istok Web","Italiana","Italianno","Itim","Jacques Francois","Jacques Francois Shadow","Jaldi","Jim Nightshade","Jockey One","Jolly Lodger","Jomhuria","Josefin Sans","Josefin Slab","Joti One","Judson","Julee","Julius Sans One","Junge","Jura","Just Another Hand","Just Me Again Down Here","Kadwa","Kalam","Kameron","Kanit","Kantumruy","Karla","Karma","Katibeh","Kaushan Script","Kavivanar","Kavoon","Kdam Thmor","Keania One","Kelly Slab","Kenia","Khand","Khmer","Khula","Kite One","Knewave","Kotta One","Koulen","Kranky","Kreon","Kristi","Krona One","Kumar One","Kumar One Outline","Kurale","La Belle Aurore","Laila","Lakki Reddy","Lalezar","Lancelot","Lateef","Lato","League Script","Leckerli One","Ledger","Lekton","Lemon","Lemonada","Libre Barcode 128","Libre Barcode 128 Text","Libre Barcode 39","Libre Barcode 39 Extended","Libre Barcode 39 Extended Text","Libre Barcode 39 Text","Libre Baskerville","Libre Franklin","Life Savers","Lilita One","Lily Script One","Limelight","Linden Hill","Lobster","Lobster Two","Londrina Outline","Londrina Shadow","Londrina Sketch","Londrina Solid","Lora","Love Ya Like A Sister","Loved by the King","Lovers Quarrel","Luckiest Guy","Lusitana","Lustria","Macondo","Macondo Swash Caps","Mada","Magra","Maiden Orange","Maitree","Mako","Mallanna","Mandali","Manuale","Marcellus","Marcellus SC","Marck Script","Margarine","Marko One","Marmelad","Martel","Martel Sans","Marvel","Mate","Mate SC","Maven Pro","McLaren","Meddon","MedievalSharp","Medula One","Meera Inimai","Megrim","Meie Script","Merienda","Merienda One","Merriweather","Merriweather Sans","Metal","Metal Mania","Metamorphous","Metrophobic","Michroma","Milonga","Miltonian","Miltonian Tattoo","Miniver","Miriam Libre","Mirza","Miss Fajardose","Mitr","Modak","Modern Antiqua","Mogra","Molengo","Molle","Monda","Monofett","Monoton","Monsieur La Doulaise","Montaga","Montez","Montserrat","Montserrat Alternates","Montserrat Subrayada","Moul","Moulpali","Mountains of Christmas","Mouse Memoirs","Mr Bedfort","Mr Dafoe","Mr De Haviland","Mrs Saint Delafield","Mrs Sheppards","Mukta","Mukta Mahee","Mukta Malar","Mukta Vaani","Muli","Mystery Quest","NTR","Neucha","Neuton","New Rocker","News Cycle","Niconne","Nixie One","Nobile","Nokora","Norican","Nosifer","Nothing You Could Do","Noticia Text","Noto Sans","Noto Serif","Nova Cut","Nova Flat","Nova Mono","Nova Oval","Nova Round","Nova Script","Nova Slim","Nova Square","Numans","Nunito","Nunito Sans","Odor Mean Chey","Offside","Old Standard TT","Oldenburg","Oleo Script","Oleo Script Swash Caps","Open Sans","Open Sans Condensed","Oranienbaum","Orbitron","Oregano","Orienta","Original Surfer","Oswald","Over the Rainbow","Overlock","Overlock SC","Overpass","Overpass Mono","Ovo","Oxygen","Oxygen Mono","PT Mono","PT Sans","PT Sans Caption","PT Sans Narrow","PT Serif","PT Serif Caption","Pacifico","Padauk","Palanquin","Palanquin Dark","Pangolin","Paprika","Parisienne","Passero One","Passion One","Pathway Gothic One","Patrick Hand","Patrick Hand SC","Pattaya","Patua One","Pavanam","Paytone One","Peddana","Peralta","Permanent Marker","Petit Formal Script","Petrona","Philosopher","Piedra","Pinyon Script","Pirata One","Plaster","Play","Playball","Playfair Display","Playfair Display SC","Podkova","Poiret One","Poller One","Poly","Pompiere","Pontano Sans","Poppins","Port Lligat Sans","Port Lligat Slab","Pragati Narrow","Prata","Preahvihear","Press Start 2P","Pridi","Princess Sofia","Prociono","Prompt","Prosto One","Proza Libre","Puritan","Purple Purse","Quando","Quantico","Quattrocento","Quattrocento Sans","Questrial","Quicksand","Quintessential","Qwigley","Racing Sans One","Radley","Rajdhani","Rakkas","Raleway","Raleway Dots","Ramabhadra","Ramaraja","Rambla","Rammetto One","Ranchers","Rancho","Ranga","Rasa","Rationale","Ravi Prakash","Redressed","Reem Kufi","Reenie Beanie","Revalia","Rhodium Libre","Ribeye","Ribeye Marrow","Righteous","Risque","Roboto","Roboto Condensed","Roboto Mono","Roboto Slab","Rochester","Rock Salt","Rokkitt","Romanesco","Ropa Sans","Rosario","Rosarivo","Rouge Script","Rozha One","Rubik","Rubik Mono One","Ruda","Rufina","Ruge Boogie","Ruluko","Rum Raisin","Ruslan Display","Russo One","Ruthie","Rye","Sacramento","Sahitya","Sail","Saira","Saira Condensed","Saira Extra Condensed","Saira Semi Condensed","Salsa","Sanchez","Sancreek","Sansita","Sarala","Sarina","Sarpanch","Satisfy","Scada","Scheherazade","Schoolbell","Scope One","Seaweed Script","Secular One","Sedgwick Ave","Sedgwick Ave Display","Sevillana","Seymour One","Shadows Into Light","Shadows Into Light Two","Shanti","Share","Share Tech","Share Tech Mono","Shojumaru","Short Stack","Shrikhand","Siemreap","Sigmar One","Signika","Signika Negative","Simonetta","Sintony","Sirin Stencil","Six Caps","Skranji","Slabo 13px","Slabo 27px","Slackey","Smokum","Smythe","Sniglet","Snippet","Snowburst One","Sofadi One","Sofia","Sonsie One","Sorts Mill Goudy","Source Code Pro","Source Sans Pro","Source Serif Pro","Space Mono","Special Elite","Spectral","Spicy Rice","Spinnaker","Spirax","Squada One","Sree Krushnadevaraya","Sriracha","Stalemate","Stalinist One","Stardos Stencil","Stint Ultra Condensed","Stint Ultra Expanded","Stoke","Strait","Sue Ellen Francisco","Suez One","Sumana","Sunshiney","Supermercado One","Sura","Suranna","Suravaram","Suwannaphum","Swanky and Moo Moo","Syncopate","Tangerine","Taprom","Tauri","Taviraj","Teko","Telex","Tenali Ramakrishna","Tenor Sans","Text Me One","The Girl Next Door","Tienne","Tillana","Timmana","Tinos","Titan One","Titillium Web","Trade Winds","Trirong","Trocchi","Trochut","Trykker","Tulpen One","Ubuntu","Ubuntu Condensed","Ubuntu Mono","Ultra","Uncial Antiqua","Underdog","Unica One","UnifrakturCook","UnifrakturMaguntia","Unkempt","Unlock","Unna","VT323","Vampiro One","Varela","Varela Round","Vast Shadow","Vesper Libre","Vibur","Vidaloka","Viga","Voces","Volkhov","Vollkorn","Voltaire","Waiting for the Sunrise","Wallpoet","Walter Turncoat","Warnes","Wellfleet","Wendy One","Wire One","Work Sans","Yanone Kaffeesatz","Yantramanav","Yatra One","Yellowtail","Yeseva One","Yesteryear","Yrsa","Zeyada","Zilla Slab","Zilla Slab Highlight"]
function getAllGoogleFonts () {
  return GOOGLE_FONTS;
}

function loadGoogleFonts (fontFamilyArray, callback) {
  if(fontFamilyArray.length === 0) return;
  WebFont.load({
    google: {
      families: fontFamilyArray,
    },
    active: callback,
  });
}

// https://stackoverflow.com/questions/20958078/resize-a-base-64-image-in-javascript-without-using-canvas
// Takes a data URI and returns the Data URI corresponding to the resized image at the wanted size.
function resizedataURL(datas, wantedWidth, wantedHeight, callback, jpeg)
    {
        // We create an image to receive the Data URI
        var img = document.createElement('img');

        // When the event "onload" is triggered we can resize the image.
        img.onload = function()
            {        
                // We create a canvas and get its context.
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');

                // We set the dimensions at the wanted size.
                canvas.width = wantedWidth;
                canvas.height = wantedHeight;

                // We resize the image with the canvas method drawImage();
                ctx.drawImage(this, 0, 0, wantedWidth, wantedHeight);

                var dataURI
                if(jpeg) {
                   dataURI = canvas.toDataURL('image/jpeg', 1.0);
                } else {
                    dataURI = canvas.toDataURL();
                }

                callback(dataURI);
            };

        // We put the Data URI in the image's src attribute
        img.src = datas;
    }
// Use it like that : resizedataURL('yourDataURIHere', 50, 50);

//https://gist.github.com/borismus/1032746
var BASE64_MARKER = ';base64,';

function convertDataURIToBinary(dataURI) {
  var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
  var base64 = dataURI.substring(base64Index);
  var raw = window.atob(base64);
  var rawLength = raw.length;
  var array = new Uint8Array(new ArrayBuffer(rawLength));

  for(i = 0; i < rawLength; i++) {
    array[i] = raw.charCodeAt(i);
  }
  return array;
}

function zeroFill( number, width )
{
  width -= number.toString().length;
  if ( width > 0 )
  {
    return new Array( width + (/\./.test( number ) ? 2 : 1) ).join( '0' ) + number;
  }
  return number + ""; // always return a string
}
</script>
<script>// https://www.npmjs.com/package/keycode
// Original key mappings lifted from http://jsfiddle.net/vWx8V/ via http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

var keyCharToCode = {
    "BACKSPACE": 8,
    "TAB": 9,
    "ENTER": 13,
    "CTRL": 17,
    "ALT": 18,
    "PAUSE/BREAK": 19,
    "CAPS LOCK": 20,
    "ESC": 27,
    "SPACE": 32,
    "PAGE UP": 33,
    "PAGE DOWN": 34,
    "END": 35,
    "HOME": 36,
    "LEFT": 37,
    "UP": 38,
    "RIGHT": 39,
    "DOWN": 40,
    "INSERT": 45,
    "DELETE": 46,
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    "A": 65,
    "B": 66,
    "C": 67,
    "D": 68,
    "E": 69,
    "F": 70,
    "G": 71,
    "H": 72,
    "I": 73,
    "J": 74,
    "K": 75,
    "L": 76,
    "M": 77,
    "N": 78,
    "O": 79,
    "P": 80,
    "Q": 81,
    "R": 82,
    "S": 83,
    "T": 84,
    "U": 85,
    "V": 86,
    "W": 87,
    "X": 88,
    "Y": 89,
    "Z": 90,
    "NUM 0": 96,
    "NUM 1": 97,
    "NUM 2": 98,
    "NUM 3": 99,
    "NUM 4": 100,
    "NUM 5": 101,
    "NUM 6": 102,
    "NUM 7": 103,
    "NUM 8": 104,
    "NUM 9": 105,
    "NUM *": 106,
    "NUM +": 107,
    "NUM -": 109,
    "NUM .": 110,
    "NUM /": 111,
    "F1": 112,
    "F2": 113,
    "F3": 114,
    "F4": 115,
    "F5": 116,
    "F6": 117,
    "F7": 118,
    "F8": 119,
    "F9": 120,
    "F10": 121,
    "F11": 122,
    "F12": 123,
    "NUM LOCK": 144,
    "SCROLL LOCK": 145,
    "MY COMPUTER": 182,
    "MY CALCULATOR": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
};

var codeToKeyChar = {};
for (var key in keyCharToCode) {
    codeToKeyChar[keyCharToCode[key]] = key;
}</script>
<script>// Framerate keeper 
// http://www.html5gamedevs.com/topic/1828-how-to-calculate-fps-in-plain-javascript/
var fps = { startTime : 0,
	frameNumber : 0,
	getFPS : function() {
		this.frameNumber++;

		var d = new Date().getTime();
		var currentTime = ( d - this.startTime ) / 1000;
		var result = Math.floor( ( this.frameNumber / currentTime ) );

		if( currentTime > 1 ) {
			this.startTime = new Date().getTime();
			this.frameNumber = 0;
		}

		return result;
	}   
};</script>
<script>/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
var Base64ArrayBuffer = (function () {
  "use strict";

  var base64ArrayBuffer = { };

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  base64ArrayBuffer.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  base64ArrayBuffer.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };

  return base64ArrayBuffer;

})();
</script>
<script>http://blog.acipo.com/blob-detection-js/

function unique(arr){
/// Returns an object with the counts of unique elements in arr
/// unique([1,2,1,1,1,2,3,4]) === { 1:4, 2:2, 3:1, 4:1 }

    var value, counts = {};
    var i, l = arr.length;
    for( i=0; i<l; i+=1) {
        value = arr[i];
        if( counts[value] ){
            counts[value] += 1;
        }else{
            counts[value] = 1;
        }
    }

    return counts;
}

function FindBlobs(src) {

  var xSize = src.width,
      ySize = src.height,
      srcPixels = src.data,
      x, y, pos;

  // This will hold the indecies of the regions we find
  var blobMap = [];
  var label = 1;

  // The labelTable remember when blobs of differen labels merge
  // so labelTabel[1] = 2; means that label 1 and 2 are the same blob
  var labelTable = [0];

  // Start by labeling every pixel as blob 0
  for(y=0; y<ySize; y++){
    blobMap.push([]);
    for(x=0; x<xSize; x++){
      blobMap[y].push(0);
    }
  }  

  // Temporary variables for neighboring pixels and other stuff
  var nn, nw, ne, ww, ee, sw, ss, se, minIndex;
  var luma = 0;
  var isVisible = 0;

  // We're going to run this algorithm twice
  // The first time identifies all of the blobs candidates the second pass
  // merges any blobs that the first pass failed to merge
  var nIter = 2;
  while( nIter-- ){

    // We leave a 1 pixel border which is ignored so we do not get array
    // out of bounds errors
    for( y=1; y<ySize-1; y++){
      for( x=1; x<xSize-1; x++){

        pos = (y*xSize+x)*4;

        // We're only looking at the alpha channel in this case but you can
        // use more complicated heuristics
        isVisible = (srcPixels[pos+3] > 0);

        if( isVisible ){

          // Find the lowest blob index nearest this pixel
          nw = blobMap[y-1][x-1] || 0;
          nn = blobMap[y-1][x-0] || 0;
          ne = blobMap[y-1][x+1] || 0;
          ww = blobMap[y-0][x-1] || 0;
          ee = blobMap[y-0][x+1] || 0;
          sw = blobMap[y+1][x-1] || 0;
          ss = blobMap[y+1][x-0] || 0;
          se = blobMap[y+1][x+1] || 0;
          minIndex = ww;
          if( 0 < ww && ww < minIndex ){ minIndex = ww; }
          if( 0 < ee && ee < minIndex ){ minIndex = ee; }
          if( 0 < nn && nn < minIndex ){ minIndex = nn; }
          if( 0 < ne && ne < minIndex ){ minIndex = ne; }
          if( 0 < nw && nw < minIndex ){ minIndex = nw; }
          if( 0 < ss && ss < minIndex ){ minIndex = ss; }
          if( 0 < se && se < minIndex ){ minIndex = se; }
          if( 0 < sw && sw < minIndex ){ minIndex = sw; }
  
          // This point starts a new blob -- increase the lable count and
          // and an entry for it in the label table
          if( minIndex === 0 ){
            blobMap[y][x] = label;
            labelTable.push(label);
            label += 1;
  
          // This point is part of an old blob -- update the labels of the
          // neighboring pixels in the label table so that we know a merge
          // should occur and mark this pixel with the label.
          }else{
            if( minIndex < labelTable[nw] ){ labelTable[nw] = minIndex; }
            if( minIndex < labelTable[nn] ){ labelTable[nn] = minIndex; }
            if( minIndex < labelTable[ne] ){ labelTable[ne] = minIndex; }
            if( minIndex < labelTable[ww] ){ labelTable[ww] = minIndex; }
            if( minIndex < labelTable[ee] ){ labelTable[ee] = minIndex; }
            if( minIndex < labelTable[sw] ){ labelTable[sw] = minIndex; }
            if( minIndex < labelTable[ss] ){ labelTable[ss] = minIndex; }
            if( minIndex < labelTable[se] ){ labelTable[se] = minIndex; }

            blobMap[y][x] = minIndex;
          }

        // This pixel isn't visible so we won't mark it as special
        }else{
          blobMap[y][x] = 0;
        }
  
      }
    }
  
    // Compress the table of labels so that every location refers to only 1
    // matching location
    var i = labelTable.length;
    while( i-- ){
      label = labelTable[i];
      while( label !== labelTable[label] ){
        label = labelTable[label];
      }
      labelTable[i] = label;
    }
  
    // Merge the blobs with multiple labels
    for(y=0; y<ySize; y++){
      for(x=0; x<xSize; x++){
        label = blobMap[y][x];
        if( label === 0 ){ continue; }
        while( label !== labelTable[label] ){
          label = labelTable[label];
        }
        blobMap[y][x] = label;
      }
    }
  }

  // The blobs may have unusual labels: [1,38,205,316,etc..]
  // Let's rename them: [1,2,3,4,etc..]

  var uniqueLabels = unique(labelTable);
  var labelCount = 0;
  for(uniqueLabel in uniqueLabels) labelCount++;

  var i = 0;
  for( label in uniqueLabels ){
    labelTable[label] = i++;
  }

  // convert the blobs to the minimized labels
  for(y=0; y<ySize; y++){
    for(x=0; x<xSize; x++){
      label = blobMap[y][x];
      blobMap[y][x] = labelTable[label];
    }
  }

  // Return the blob data:
  return {blobMap:blobMap, nBlobs:labelCount};

};


function ColorTheBlobs(dst,blobs,colors){
    var xSize = dst.width,
        ySize = dst.height,
        dstPixels = dst.data,
        x, y, pos;

    var label, color, nColors = colors.length;

    for(y=0; y<ySize; y++){
        for(x=0; x<xSize; x++){
            pos = (y*xSize+x)*4;

            label = blobs[y][x];

            if( label !== 0 ){
                color = colors[ label % nColors ];
                dstPixels[ pos+0 ] = color[0];
                dstPixels[ pos+1 ] = color[1];
                dstPixels[ pos+2 ] = color[2];
                dstPixels[ pos+3 ] = color[3];
            }else{
                dstPixels[ pos+3 ] = 0;
            }
        }
    }

}

function GetBlobMap (img, callback) {
  ImageToCanvas(img, function (canvas,context) {
    var canvas = canvas;//document.getElementById('canvas-draw');
    var contex = context;//canvas.getContext('2d');
    var imageData = contex.getImageData(0,0,canvas.width,canvas.height);

    var blobResults = FindBlobs(imageData);
    var blobLabels = blobResults.blobMap;
    var nBlobs = blobResults.nBlobs;

    var blobCanvas = document.createElement('canvas');//document.getElementById('canvas-blob');
    blobCanvas.width = canvas.width;
    blobCanvas.height = canvas.height;
    var blobContex = blobCanvas.getContext('2d');
    var blobImageData = contex.getImageData(0,0,canvas.width,canvas.height);

    // this means you can only have 255 blobs, ya dummy!
    var colors = [];
    for(var i = 0; i <= 255; i+=1) {
      colors.push([i,0,0,255]);
    }
    ColorTheBlobs(blobImageData,blobLabels,colors);
    
    blobContex.putImageData(blobImageData,0,0);

    var blobMap = new Image();
    blobMap.onload = function () {
      callback({blobMap:blobMap, nBlobs:nBlobs});
    }
    blobMap.src = blobCanvas.toDataURL();
  });
}

function GetBlobImages (blobMap, nBlobs, image, callback) {
	var imagesData = [];

	var label;
	for(label=1; label<=nBlobs; label++) {
		imagesData[label] = GetBlobImage(blobMap, image, label);
	}

	var images = [];
	var done = false;

	function processBlobImage (i) {
		var data = imagesData[i];
		if(data) {
			ctx.putImageData(data,0,0);

			var image = new Image();
			image.onload = function () {
				//callback(image);
				images.push(image);
				if(images.length >= nBlobs-1) {
					if(!done) callback(images);
					done = true;
				}
			}
			image.src = canvas.toDataURL();
		}
	}

	for(label=1; label<=nBlobs; label++) {
		if(done) return;

		var canvas = document.createElement('canvas');
		canvas.width = image.width;
		canvas.height = image.height;
		var ctx = canvas.getContext('2d');

		processBlobImage(label);
	}
}

function GetBlobImage (blobMap, originalImg, label) {

	var blobMapData = ImageToImageData(blobMap)
	var originalImgData = ImageToImageData(originalImg)

	var xSize = blobMapData.width,
        ySize = blobMapData.height,
        blobMapPixels = blobMapData.data,
        x, y, pos;

    var originalImgPixels = originalImgData.data;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var newImgData = ctx.createImageData(originalImgData);
    var newImagePixels = newImgData.data;

    var blobExistsWithLabel = false;

    for(y=0; y<ySize; y++){
        for(x=0; x<xSize; x++){
            pos = (y*xSize+x)*4;

            if(blobMapPixels[ pos+0 ] === label) {
            	newImagePixels[ pos+0 ] = originalImgPixels[ pos+0 ];
            	newImagePixels[ pos+1 ] = originalImgPixels[ pos+1 ];
            	newImagePixels[ pos+2 ] = originalImgPixels[ pos+2 ];
            	newImagePixels[ pos+3 ] = originalImgPixels[ pos+3 ];
            	blobExistsWithLabel = true;
            } else {
            	newImagePixels[ pos+0 ] = 0;
	            newImagePixels[ pos+1 ] = 0;
	            newImagePixels[ pos+2 ] = 0;
	            newImagePixels[ pos+3 ] = 0;
            }
        }
    }

    return blobExistsWithLabel ? newImgData : null;
}

function FindBlobsAndGetBlobImages (imgData, callback) {

	GetBlobMap(imgData, function (blobResult) {
        var img = new Image();
        img.onload = function () {
            GetBlobImages(blobResult.blobMap, blobResult.nBlobs, img, function (blobImages) {
                callback(blobImages);
            });
        }
        img.src = imgData;
    });

}

// Image cropping / padding (zrispo)

var CropImage = function (src, callback, args) {
    var canvas = document.createElement('canvas');
    canvas.width = args.width;
    canvas.height = args.height;

    var context = canvas.getContext('2d');
    var imageObj = new Image();

    imageObj.onload = function() {
        // draw cropped image
        var sourceX = args.x;
        var sourceY = args.y;
        var sourceWidth = args.width;
        var sourceHeight = args.height;
        var destWidth = sourceWidth;
        var destHeight = sourceHeight;
        var destX = canvas.width / 2 - destWidth / 2;
        var destY = canvas.height / 2 - destHeight / 2;

        context.drawImage(imageObj, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);

        callback(canvas.toDataURL());
    };

    imageObj.src = src;
}

function AddPaddingToImage (img, callback) {
    var oddWidth = img.width % 2 === 1;
    var oddHeight = img.height % 2 === 1;

    if (oddWidth && oddHeight) {
        CropImage(img.src, callback, {
            x: 0,
            y: 0,
            width: img.width+1,
            height: img.height+1
        });
    } else if (oddWidth) {
        CropImage(img.src, callback, {
            x: 0,
            y: 0,
            width: img.width+1,
            height: img.height
        });
    } else if (oddHeight) {
        CropImage(img.src, callback, {
            x: 0,
            y: 0,
            width: img.width,
            height: img.height+1
        });
    } else {
        callback(img.src);
    }

}

// Canvas <-> Image conversion (zrispo)

var ImageToCanvas = function (src, callback, args) {

  var image = new Image();
    image.onload = function () {
      var w = image.width;
        var h = image.height;

        if(args && args.width)  w = args.width;
        if(args && args.height) h = args.height;

        var canvas = document.createElement('canvas');
        canvas.height = h;
        canvas.width = w;
        
        var ctx = canvas.getContext('2d');
        ctx.drawImage( image, 0, 0, w, h );
        callback(canvas,ctx);
    };
    image.setAttribute('crossOrigin', 'anonymous');
    image.src = src;

}

function ImageToImageData (img) {
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0)
    return ctx.getImageData(0,0,canvas.width,canvas.height);
}

function PixelsToImageData (pixelData) {

}

// Color picking (unknown source??)

var GetColorAtCoords = function (img, x, y, format) {
  
  if(x < 0 || y < 0 || x > img.width || y > img.height) {
    console.error("GetColorAtCoords: coords out of bounds: ("+x+","+y+")")
  }

  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var context = canvas.getContext('2d');
  context.drawImage(img, 0, 0);
  var data = context.getImageData(0, 0, canvas.width, canvas.height).data;

  var i = (x + y*img.width) * 4;

  var color = {};
  color.r = data[i+0];
  color.g = data[i+1];
  color.b = data[i+2];
  color.a = data[i+3];

  if (!format) {
    return color;
  }

  if (format === "rgba") {
    return color;
  } else if (format === "hex") {
    // http://jsfiddle.net/Mottie/xcqpF/1/light/
    function rgb2hex(rgb){
      rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return (rgb && rgb.length === 4) ? "#" +
        ("0" + parseInt(rgb[1],10).toString(16)).slice(-2) +
        ("0" + parseInt(rgb[2],10).toString(16)).slice(-2) +
        ("0" + parseInt(rgb[3],10).toString(16)).slice(-2) : '';
    }
    return rgb2hex("rgb("+color.r+","+color.g+","+color.b+")").toUpperCase();
  }

}

// Blank pixel remover / cropper

// http://stackoverflow.com/questions/12175991/crop-image-white-space-automatically-using-jquery

var removeBlankPixels = function (img, imgWidth, imgHeight) {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = img.width;
    canvas.height = img.height;
    context.drawImage(img, 0, 0)

    var imageData = context.getImageData(0, 0, imgWidth, imgHeight),
        data = imageData.data,
        getRBG = function(x, y) {
            var offset = imgWidth * y + x;
            return {
                red:     data[offset * 4],
                green:   data[offset * 4 + 1],
                blue:    data[offset * 4 + 2],
                opacity: data[offset * 4 + 3]
            };
        },
        isWhite = function (rgb) {
            // many images contain noise, as the white is not a pure #fff white
            //return rgb.red > 200 && rgb.green > 200 && rgb.blue > 200;
            return rgb.opacity === 0;
        },
        scanY = function (fromTop) {
            var offset = fromTop ? 1 : -1;
            
            // loop through each row
            for(var y = fromTop ? 0 : imgHeight - 1; fromTop ? (y < imgHeight) : (y > -1); y += offset) {
                
                // loop through each column
                for(var x = 0; x < imgWidth; x++) {
                    var rgb = getRBG(x, y);
                    if (!isWhite(rgb)) {
                        return y;                        
                    }      
                }
            }
            return null; // all image is white
        },
        scanX = function (fromLeft) {
            var offset = fromLeft? 1 : -1;
            
            // loop through each column
            for(var x = fromLeft ? 0 : imgWidth - 1; fromLeft ? (x < imgWidth) : (x > -1); x += offset) {
                
                // loop through each row
                for(var y = 0; y < imgHeight; y++) {
                    var rgb = getRBG(x, y);
                    if (!isWhite(rgb)) {
                        return x;                        
                    }      
                }
            }
            return null; // all image is white
        };
    
    var cropTop = scanY(true),
        cropBottom = scanY(false),
        cropLeft = scanX(true),
        cropRight = scanX(false),
        cropWidth = cropRight - cropLeft + 1,
        cropHeight = cropBottom - cropTop + 1;
    
    var croppedCanvas = document.createElement('canvas');
    croppedCanvas.width = cropWidth;
    croppedCanvas.height = cropHeight;

    //$("<canvas>").attr({ width: cropWidth, height: cropHeight });
    
    // finally crop the guy
    croppedCanvas.getContext("2d").drawImage(
        canvas,
        cropLeft, cropTop, 
        cropWidth, cropHeight,
        0, 0, 
        cropWidth, cropHeight );
    
    /*$("body").
        append("<p>same image with white spaces cropped:</p>").
        append($croppedCanvas);*/
    //console.log(cropTop, cropBottom, cropLeft, cropRight);

    var dataURL = croppedCanvas.toDataURL();
    return {dataURL:dataURL, left:cropLeft, top:cropTop};
};

function getColorIndicesForCoord(x, y, width) {
  var red = y * (width * 4) + x * 4;
  return {
    r: red,
    g: red+1,
    b: red+2,
    a: red+3,
  }
  //[red, red + 1, red + 2, red + 3];
}

function getPixelAt (x,y,width,height,imageData) {
  if(x<0 || y<0 || x>=width || y>=height) return null;

  var offset = (y*width+x)*4;
  return {
    r: imageData[offset],
    g: imageData[offset+1],
    b: imageData[offset+2],
    a: imageData[offset+3]
  }
}

function setPixelAt (x,y,width,height,imageData,color) {
  var offset = (y*width+x)*4;
  imageData[offset] = color.r
  imageData[offset+1] = color.g
  imageData[offset+2] = color.b
  imageData[offset+3] = color.a
}
</script>
<script>/*jshint eqnull:true*/
(function (root) {
  "use strict";

  var GLOBAL_KEY = "Random";

  var imul = (typeof Math.imul !== "function" || Math.imul(0xffffffff, 5) !== -5 ?
    function (a, b) {
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0;
    } :
    Math.imul);

  var stringRepeat = (typeof String.prototype.repeat === "function" && "x".repeat(3) === "xxx" ?
    function (x, y) {
      return x.repeat(y);
    } : function (pattern, count) {
      var result = "";
      while (count > 0) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result;
    });

  function Random(engine) {
    if (!(this instanceof Random)) {
      return new Random(engine);
    }

    if (engine == null) {
      engine = Random.engines.nativeMath;
    } else if (typeof engine !== "function") {
      throw new TypeError("Expected engine to be a function, got " + typeof engine);
    }
    this.engine = engine;
  }
  var proto = Random.prototype;

  Random.engines = {
    nativeMath: function () {
      return (Math.random() * 0x100000000) | 0;
    },
    mt19937: (function (Int32Array) {
      // http://en.wikipedia.org/wiki/Mersenne_twister
      function refreshData(data) {
        var k = 0;
        var tmp = 0;
        for (;
          (k | 0) < 227; k = (k + 1) | 0) {
          tmp = (data[k] & 0x80000000) | (data[(k + 1) | 0] & 0x7fffffff);
          data[k] = data[(k + 397) | 0] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
        }

        for (;
          (k | 0) < 623; k = (k + 1) | 0) {
          tmp = (data[k] & 0x80000000) | (data[(k + 1) | 0] & 0x7fffffff);
          data[k] = data[(k - 227) | 0] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
        }

        tmp = (data[623] & 0x80000000) | (data[0] & 0x7fffffff);
        data[623] = data[396] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
      }

      function temper(value) {
        value ^= value >>> 11;
        value ^= (value << 7) & 0x9d2c5680;
        value ^= (value << 15) & 0xefc60000;
        return value ^ (value >>> 18);
      }

      function seedWithArray(data, source) {
        var i = 1;
        var j = 0;
        var sourceLength = source.length;
        var k = Math.max(sourceLength, 624) | 0;
        var previous = data[0] | 0;
        for (;
          (k | 0) > 0; --k) {
          data[i] = previous = ((data[i] ^ imul((previous ^ (previous >>> 30)), 0x0019660d)) + (source[j] | 0) + (j | 0)) | 0;
          i = (i + 1) | 0;
          ++j;
          if ((i | 0) > 623) {
            data[0] = data[623];
            i = 1;
          }
          if (j >= sourceLength) {
            j = 0;
          }
        }
        for (k = 623;
          (k | 0) > 0; --k) {
          data[i] = previous = ((data[i] ^ imul((previous ^ (previous >>> 30)), 0x5d588b65)) - i) | 0;
          i = (i + 1) | 0;
          if ((i | 0) > 623) {
            data[0] = data[623];
            i = 1;
          }
        }
        data[0] = 0x80000000;
      }

      function mt19937() {
        var data = new Int32Array(624);
        var index = 0;
        var uses = 0;

        function next() {
          if ((index | 0) >= 624) {
            refreshData(data);
            index = 0;
          }

          var value = data[index];
          index = (index + 1) | 0;
          uses += 1;
          return temper(value) | 0;
        }
        next.getUseCount = function() {
          return uses;
        };
        next.discard = function (count) {
          uses += count;
          if ((index | 0) >= 624) {
            refreshData(data);
            index = 0;
          }
          while ((count - index) > 624) {
            count -= 624 - index;
            refreshData(data);
            index = 0;
          }
          index = (index + count) | 0;
          return next;
        };
        next.seed = function (initial) {
          var previous = 0;
          data[0] = previous = initial | 0;

          for (var i = 1; i < 624; i = (i + 1) | 0) {
            data[i] = previous = (imul((previous ^ (previous >>> 30)), 0x6c078965) + i) | 0;
          }
          index = 624;
          uses = 0;
          return next;
        };
        next.seedWithArray = function (source) {
          next.seed(0x012bd6aa);
          seedWithArray(data, source);
          return next;
        };
        next.autoSeed = function () {
          return next.seedWithArray(Random.generateEntropyArray());
        };
        return next;
      }

      return mt19937;
    }(typeof Int32Array === "function" ? Int32Array : Array)),
    browserCrypto: (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function" && typeof Int32Array === "function") ? (function () {
      var data = null;
      var index = 128;

      return function () {
        if (index >= 128) {
          if (data === null) {
            data = new Int32Array(128);
          }
          crypto.getRandomValues(data);
          index = 0;
        }

        return data[index++] | 0;
      };
    }()) : null
  };

  Random.generateEntropyArray = function () {
    var array = [];
    var engine = Random.engines.nativeMath;
    for (var i = 0; i < 16; ++i) {
      array[i] = engine() | 0;
    }
    array.push(new Date().getTime() | 0);
    return array;
  };

  function returnValue(value) {
    return function () {
      return value;
    };
  }

  // [-0x80000000, 0x7fffffff]
  Random.int32 = function (engine) {
    return engine() | 0;
  };
  proto.int32 = function () {
    return Random.int32(this.engine);
  };

  // [0, 0xffffffff]
  Random.uint32 = function (engine) {
    return engine() >>> 0;
  };
  proto.uint32 = function () {
    return Random.uint32(this.engine);
  };

  // [0, 0x1fffffffffffff]
  Random.uint53 = function (engine) {
    var high = engine() & 0x1fffff;
    var low = engine() >>> 0;
    return (high * 0x100000000) + low;
  };
  proto.uint53 = function () {
    return Random.uint53(this.engine);
  };

  // [0, 0x20000000000000]
  Random.uint53Full = function (engine) {
    while (true) {
      var high = engine() | 0;
      if (high & 0x200000) {
        if ((high & 0x3fffff) === 0x200000 && (engine() | 0) === 0) {
          return 0x20000000000000;
        }
      } else {
        var low = engine() >>> 0;
        return ((high & 0x1fffff) * 0x100000000) + low;
      }
    }
  };
  proto.uint53Full = function () {
    return Random.uint53Full(this.engine);
  };

  // [-0x20000000000000, 0x1fffffffffffff]
  Random.int53 = function (engine) {
    var high = engine() | 0;
    var low = engine() >>> 0;
    return ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
  };
  proto.int53 = function () {
    return Random.int53(this.engine);
  };

  // [-0x20000000000000, 0x20000000000000]
  Random.int53Full = function (engine) {
    while (true) {
      var high = engine() | 0;
      if (high & 0x400000) {
        if ((high & 0x7fffff) === 0x400000 && (engine() | 0) === 0) {
          return 0x20000000000000;
        }
      } else {
        var low = engine() >>> 0;
        return ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
      }
    }
  };
  proto.int53Full = function () {
    return Random.int53Full(this.engine);
  };

  function add(generate, addend) {
    if (addend === 0) {
      return generate;
    } else {
      return function (engine) {
        return generate(engine) + addend;
      };
    }
  }

  Random.integer = (function () {
    function isPowerOfTwoMinusOne(value) {
      return ((value + 1) & value) === 0;
    }

    function bitmask(masking) {
      return function (engine) {
        return engine() & masking;
      };
    }

    function downscaleToLoopCheckedRange(range) {
      var extendedRange = range + 1;
      var maximum = extendedRange * Math.floor(0x100000000 / extendedRange);
      return function (engine) {
        var value = 0;
        do {
          value = engine() >>> 0;
        } while (value >= maximum);
        return value % extendedRange;
      };
    }

    function downscaleToRange(range) {
      if (isPowerOfTwoMinusOne(range)) {
        return bitmask(range);
      } else {
        return downscaleToLoopCheckedRange(range);
      }
    }

    function isEvenlyDivisibleByMaxInt32(value) {
      return (value | 0) === 0;
    }

    function upscaleWithHighMasking(masking) {
      return function (engine) {
        var high = engine() & masking;
        var low = engine() >>> 0;
        return (high * 0x100000000) + low;
      };
    }

    function upscaleToLoopCheckedRange(extendedRange) {
      var maximum = extendedRange * Math.floor(0x20000000000000 / extendedRange);
      return function (engine) {
        var ret = 0;
        do {
          var high = engine() & 0x1fffff;
          var low = engine() >>> 0;
          ret = (high * 0x100000000) + low;
        } while (ret >= maximum);
        return ret % extendedRange;
      };
    }

    function upscaleWithinU53(range) {
      var extendedRange = range + 1;
      if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
        var highRange = ((extendedRange / 0x100000000) | 0) - 1;
        if (isPowerOfTwoMinusOne(highRange)) {
          return upscaleWithHighMasking(highRange);
        }
      }
      return upscaleToLoopCheckedRange(extendedRange);
    }

    function upscaleWithinI53AndLoopCheck(min, max) {
      return function (engine) {
        var ret = 0;
        do {
          var high = engine() | 0;
          var low = engine() >>> 0;
          ret = ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
        } while (ret < min || ret > max);
        return ret;
      };
    }

    return function (min, max) {
      min = Math.floor(min);
      max = Math.floor(max);
      if (min < -0x20000000000000 || !isFinite(min)) {
        throw new RangeError("Expected min to be at least " + (-0x20000000000000));
      } else if (max > 0x20000000000000 || !isFinite(max)) {
        throw new RangeError("Expected max to be at most " + 0x20000000000000);
      }

      var range = max - min;
      if (range <= 0 || !isFinite(range)) {
        return returnValue(min);
      } else if (range === 0xffffffff) {
        if (min === 0) {
          return Random.uint32;
        } else {
          return add(Random.int32, min + 0x80000000);
        }
      } else if (range < 0xffffffff) {
        return add(downscaleToRange(range), min);
      } else if (range === 0x1fffffffffffff) {
        return add(Random.uint53, min);
      } else if (range < 0x1fffffffffffff) {
        return add(upscaleWithinU53(range), min);
      } else if (max - 1 - min === 0x1fffffffffffff) {
        return add(Random.uint53Full, min);
      } else if (min === -0x20000000000000 && max === 0x20000000000000) {
        return Random.int53Full;
      } else if (min === -0x20000000000000 && max === 0x1fffffffffffff) {
        return Random.int53;
      } else if (min === -0x1fffffffffffff && max === 0x20000000000000) {
        return add(Random.int53, 1);
      } else if (max === 0x20000000000000) {
        return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);
      } else {
        return upscaleWithinI53AndLoopCheck(min, max);
      }
    };
  }());
  proto.integer = function (min, max) {
    return Random.integer(min, max)(this.engine);
  };

  // [0, 1] (floating point)
  Random.realZeroToOneInclusive = function (engine) {
    return Random.uint53Full(engine) / 0x20000000000000;
  };
  proto.realZeroToOneInclusive = function () {
    return Random.realZeroToOneInclusive(this.engine);
  };

  // [0, 1) (floating point)
  Random.realZeroToOneExclusive = function (engine) {
    return Random.uint53(engine) / 0x20000000000000;
  };
  proto.realZeroToOneExclusive = function () {
    return Random.realZeroToOneExclusive(this.engine);
  };

  Random.real = (function () {
    function multiply(generate, multiplier) {
      if (multiplier === 1) {
        return generate;
      } else if (multiplier === 0) {
        return function () {
          return 0;
        };
      } else {
        return function (engine) {
          return generate(engine) * multiplier;
        };
      }
    }

    return function (left, right, inclusive) {
      if (!isFinite(left)) {
        throw new RangeError("Expected left to be a finite number");
      } else if (!isFinite(right)) {
        throw new RangeError("Expected right to be a finite number");
      }
      return add(
        multiply(
          inclusive ? Random.realZeroToOneInclusive : Random.realZeroToOneExclusive,
          right - left),
        left);
    };
  }());
  proto.real = function (min, max, inclusive) {
    return Random.real(min, max, inclusive)(this.engine);
  };

  Random.bool = (function () {
    function isLeastBitTrue(engine) {
      return (engine() & 1) === 1;
    }

    function lessThan(generate, value) {
      return function (engine) {
        return generate(engine) < value;
      };
    }

    function probability(percentage) {
      if (percentage <= 0) {
        return returnValue(false);
      } else if (percentage >= 1) {
        return returnValue(true);
      } else {
        var scaled = percentage * 0x100000000;
        if (scaled % 1 === 0) {
          return lessThan(Random.int32, (scaled - 0x80000000) | 0);
        } else {
          return lessThan(Random.uint53, Math.round(percentage * 0x20000000000000));
        }
      }
    }

    return function (numerator, denominator) {
      if (denominator == null) {
        if (numerator == null) {
          return isLeastBitTrue;
        }
        return probability(numerator);
      } else {
        if (numerator <= 0) {
          return returnValue(false);
        } else if (numerator >= denominator) {
          return returnValue(true);
        }
        return lessThan(Random.integer(0, denominator - 1), numerator);
      }
    };
  }());
  proto.bool = function (numerator, denominator) {
    return Random.bool(numerator, denominator)(this.engine);
  };

  function toInteger(value) {
    var number = +value;
    if (number < 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }

  function convertSliceArgument(value, length) {
    if (value < 0) {
      return Math.max(value + length, 0);
    } else {
      return Math.min(value, length);
    }
  }
  Random.pick = function (engine, array, begin, end) {
    var length = array.length;
    var start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
    var finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);
    if (start >= finish) {
      return void 0;
    }
    var distribution = Random.integer(start, finish - 1);
    return array[distribution(engine)];
  };
  proto.pick = function (array, begin, end) {
    return Random.pick(this.engine, array, begin, end);
  };

  function returnUndefined() {
    return void 0;
  }
  var slice = Array.prototype.slice;
  Random.picker = function (array, begin, end) {
    var clone = slice.call(array, begin, end);
    if (!clone.length) {
      return returnUndefined;
    }
    var distribution = Random.integer(0, clone.length - 1);
    return function (engine) {
      return clone[distribution(engine)];
    };
  };

  Random.shuffle = function (engine, array, downTo) {
    var length = array.length;
    if (length) {
      if (downTo == null) {
        downTo = 0;
      }
      for (var i = (length - 1) >>> 0; i > downTo; --i) {
        var distribution = Random.integer(0, i);
        var j = distribution(engine);
        if (i !== j) {
          var tmp = array[i];
          array[i] = array[j];
          array[j] = tmp;
        }
      }
    }
    return array;
  };
  proto.shuffle = function (array) {
    return Random.shuffle(this.engine, array);
  };

  Random.sample = function (engine, population, sampleSize) {
    if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
      throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
    }

    if (sampleSize === 0) {
      return [];
    }

    var clone = slice.call(population);
    var length = clone.length;
    if (length === sampleSize) {
      return Random.shuffle(engine, clone, 0);
    }
    var tailLength = length - sampleSize;
    return Random.shuffle(engine, clone, tailLength - 1).slice(tailLength);
  };
  proto.sample = function (population, sampleSize) {
    return Random.sample(this.engine, population, sampleSize);
  };

  Random.die = function (sideCount) {
    return Random.integer(1, sideCount);
  };
  proto.die = function (sideCount) {
    return Random.die(sideCount)(this.engine);
  };

  Random.dice = function (sideCount, dieCount) {
    var distribution = Random.die(sideCount);
    return function (engine) {
      var result = [];
      result.length = dieCount;
      for (var i = 0; i < dieCount; ++i) {
        result[i] = distribution(engine);
      }
      return result;
    };
  };
  proto.dice = function (sideCount, dieCount) {
    return Random.dice(sideCount, dieCount)(this.engine);
  };

  // http://en.wikipedia.org/wiki/Universally_unique_identifier
  Random.uuid4 = (function () {
    function zeroPad(string, zeroCount) {
      return stringRepeat("0", zeroCount - string.length) + string;
    }

    return function (engine) {
      var a = engine() >>> 0;
      var b = engine() | 0;
      var c = engine() | 0;
      var d = engine() >>> 0;

      return (
        zeroPad(a.toString(16), 8) +
        "-" +
        zeroPad((b & 0xffff).toString(16), 4) +
        "-" +
        zeroPad((((b >> 4) & 0x0fff) | 0x4000).toString(16), 4) +
        "-" +
        zeroPad(((c & 0x3fff) | 0x8000).toString(16), 4) +
        "-" +
        zeroPad(((c >> 4) & 0xffff).toString(16), 4) +
        zeroPad(d.toString(16), 8));
    };
  }());
  proto.uuid4 = function () {
    return Random.uuid4(this.engine);
  };

  Random.string = (function () {
    // has 2**x chars, for faster uniform distribution
    var DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";

    return function (pool) {
      if (pool == null) {
        pool = DEFAULT_STRING_POOL;
      }

      var length = pool.length;
      if (!length) {
        throw new Error("Expected pool not to be an empty string");
      }

      var distribution = Random.integer(0, length - 1);
      return function (engine, length) {
        var result = "";
        for (var i = 0; i < length; ++i) {
          var j = distribution(engine);
          result += pool.charAt(j);
        }
        return result;
      };
    };
  }());
  proto.string = function (length, pool) {
    return Random.string(pool)(this.engine, length);
  };

  Random.hex = (function () {
    var LOWER_HEX_POOL = "0123456789abcdef";
    var lowerHex = Random.string(LOWER_HEX_POOL);
    var upperHex = Random.string(LOWER_HEX_POOL.toUpperCase());

    return function (upper) {
      if (upper) {
        return upperHex;
      } else {
        return lowerHex;
      }
    };
  }());
  proto.hex = function (length, upper) {
    return Random.hex(upper)(this.engine, length);
  };

  Random.date = function (start, end) {
    if (!(start instanceof Date)) {
      throw new TypeError("Expected start to be a Date, got " + typeof start);
    } else if (!(end instanceof Date)) {
      throw new TypeError("Expected end to be a Date, got " + typeof end);
    }
    var distribution = Random.integer(start.getTime(), end.getTime());
    return function (engine) {
      return new Date(distribution(engine));
    };
  };
  proto.date = function (start, end) {
    return Random.date(start, end)(this.engine);
  };

  if (typeof define === "function" && define.amd) {
    define(function () {
      return Random;
    });
  } else if (typeof module !== "undefined" && typeof require === "function") {
    module.exports = Random;
  } else {
    (function () {
      var oldGlobal = root[GLOBAL_KEY];
      Random.noConflict = function () {
        root[GLOBAL_KEY] = oldGlobal;
        return this;
      };
    }());
    root[GLOBAL_KEY] = Random;
  }
}(this));

window.random = new Random();
window.randomInt = function (min,max) { return random.integer(min,max); };
window.randomBool = function () { return random.bool() };
window.randomFloat = function (min,max) { return random.real(min,max); };</script>
<script>/* SAT.js - Version 0.6.0 - Copyright 2012 - 2016 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */
function x(){function c(a,e){this.x=a||0;this.y=e||0}function B(a,e){this.pos=a||new c;this.r=e||0}function n(a,e){this.pos=a||new c;this.angle=0;this.offset=new c;this.u(e||[])}function q(a,e,b){this.pos=a||new c;this.w=e||0;this.h=b||0}function w(){this.b=this.a=null;this.overlapN=new c;this.overlapV=new c;this.clear()}function C(a,e,b){for(var h=Number.MAX_VALUE,c=-Number.MAX_VALUE,k=a.length,g=0;g<k;g++){var d=a[g].f(e);d<h&&(h=d);d>c&&(c=d)}b[0]=h;b[1]=c}function y(a,e,b,h,c,k){var g=r.pop(),
d=r.pop();a=m.pop().c(e).sub(a);e=a.f(c);C(b,c,g);C(h,c,d);d[0]+=e;d[1]+=e;if(g[0]>d[1]||d[0]>g[1])return m.push(a),r.push(g),r.push(d),!0;k&&(g[0]<d[0]?(k.aInB=!1,g[1]<d[1]?(b=g[1]-d[0],k.bInA=!1):(b=g[1]-d[0],h=d[1]-g[0],b=b<h?b:-h)):(k.bInA=!1,g[1]>d[1]?(b=g[0]-d[1],k.aInB=!1):(b=g[1]-d[0],h=d[1]-g[0],b=b<h?b:-h)),h=Math.abs(b),h<k.overlap&&(k.overlap=h,k.overlapN.c(c),0>b&&k.overlapN.reverse()));m.push(a);r.push(g);r.push(d);return!1}function z(a,e){var b=a.g(),c=e.f(a);return 0>c?-1:c>b?1:0}
function D(a,e,b){for(var c=m.pop().c(e.pos).sub(a.pos),l=e.r,k=l*l,g=a.calcPoints,d=g.length,u=m.pop(),f=m.pop(),n=0;n<d;n++){var v=n===d-1?0:n+1,r=0===n?d-1:n-1,q=0,t=null;u.c(a.edges[n]);f.c(c).sub(g[n]);b&&f.g()>k&&(b.aInB=!1);var p=z(u,f);if(-1===p){u.c(a.edges[r]);v=m.pop().c(c).sub(g[r]);p=z(u,v);if(1===p){p=f.j();if(p>l)return m.push(c),m.push(u),m.push(f),m.push(v),!1;b&&(b.bInA=!1,t=f.normalize(),q=l-p)}m.push(v)}else if(1===p){if(u.c(a.edges[v]),f.c(c).sub(g[v]),p=z(u,f),-1===p){p=f.j();
if(p>l)return m.push(c),m.push(u),m.push(f),!1;b&&(b.bInA=!1,t=f.normalize(),q=l-p)}}else{v=u.m().normalize();p=f.f(v);r=Math.abs(p);if(0<p&&r>l)return m.push(c),m.push(v),m.push(f),!1;b&&(t=v,q=l-p,0<=p||q<2*l)&&(b.bInA=!1)}t&&b&&Math.abs(q)<Math.abs(b.overlap)&&(b.overlap=q,b.overlapN.c(t))}b&&(b.a=a,b.b=e,b.overlapV.c(b.overlapN).scale(b.overlap));m.push(c);m.push(u);m.push(f);return!0}function E(a,e,b){for(var c=a.calcPoints,l=c.length,k=e.calcPoints,g=k.length,d=0;d<l;d++)if(y(a.pos,e.pos,c,
k,a.normals[d],b))return!1;for(d=0;d<g;d++)if(y(a.pos,e.pos,c,k,e.normals[d],b))return!1;b&&(b.a=a,b.b=e,b.overlapV.c(b.overlapN).scale(b.overlap));return!0}var f={};f.Vector=c;f.V=c;c.prototype.copy=c.prototype.c=function(a){this.x=a.x;this.y=a.y;return this};c.prototype.clone=c.prototype.clone=function(){return new c(this.x,this.y)};c.prototype.perp=c.prototype.m=function(){var a=this.x;this.x=this.y;this.y=-a;return this};c.prototype.rotate=c.prototype.rotate=function(a){var e=this.x,b=this.y;
this.x=e*Math.cos(a)-b*Math.sin(a);this.y=e*Math.sin(a)+b*Math.cos(a);return this};c.prototype.reverse=c.prototype.reverse=function(){this.x=-this.x;this.y=-this.y;return this};c.prototype.normalize=c.prototype.normalize=function(){var a=this.j();0<a&&(this.x/=a,this.y/=a);return this};c.prototype.add=c.prototype.add=function(a){this.x+=a.x;this.y+=a.y;return this};c.prototype.sub=c.prototype.sub=function(a){this.x-=a.x;this.y-=a.y;return this};c.prototype.scale=c.prototype.scale=function(a,e){this.x*=
a;this.y*=e||a;return this};c.prototype.project=c.prototype.o=function(a){var e=this.f(a)/a.g();this.x=e*a.x;this.y=e*a.y;return this};c.prototype.projectN=c.prototype.s=function(a){var e=this.f(a);this.x=e*a.x;this.y=e*a.y;return this};c.prototype.reflect=function(a){var e=this.x,b=this.y;this.o(a).scale(2);this.x-=e;this.y-=b;return this};c.prototype.reflectN=function(a){var e=this.x,b=this.y;this.s(a).scale(2);this.x-=e;this.y-=b;return this};c.prototype.dot=c.prototype.f=function(a){return this.x*
a.x+this.y*a.y};c.prototype.len2=c.prototype.g=function(){return this.f(this)};c.prototype.len=c.prototype.j=function(){return Math.sqrt(this.g())};f.Circle=B;B.prototype.getAABB=function(){var a=this.r,e=this.pos.clone().sub(new c(a,a));return(new q(e,2*a,2*a)).l()};f.Polygon=n;n.prototype.setPoints=n.prototype.u=function(a){if(!this.points||this.points.length!==a.length){var e,b=this.calcPoints=[],h=this.edges=[],l=this.normals=[];for(e=0;e<a.length;e++)b.push(new c),h.push(new c),l.push(new c)}this.points=
a;this.i();return this};n.prototype.setAngle=function(a){this.angle=a;this.i();return this};n.prototype.setOffset=function(a){this.offset=a;this.i();return this};n.prototype.rotate=n.prototype.rotate=function(a){for(var e=this.points,b=e.length,c=0;c<b;c++)e[c].rotate(a);this.i();return this};n.prototype.translate=n.prototype.translate=function(a,c){for(var b=this.points,h=b.length,l=0;l<h;l++)b[l].x+=a,b[l].y+=c;this.i();return this};n.prototype.i=function(){var a=this.calcPoints,c=this.edges,b=
this.normals,h=this.points,l=this.offset,k=this.angle,g=h.length,d;for(d=0;d<g;d++){var f=a[d].c(h[d]);f.x+=l.x;f.y+=l.y;0!==k&&f.rotate(k)}for(d=0;d<g;d++)h=a[d],h=c[d].c(d<g-1?a[d+1]:a[0]).sub(h),b[d].c(h).m().normalize()};n.prototype.getAABB=function(){for(var a=this.calcPoints,e=a.length,b=a[0].x,h=a[0].y,f=a[0].x,k=a[0].y,g=1;g<e;g++){var d=a[g];d.x<b?b=d.x:d.x>f&&(f=d.x);d.y<h?h=d.y:d.y>k&&(k=d.y)}return(new q(this.pos.clone().add(new c(b,h)),f-b,k-h)).l()};f.Box=q;q.prototype.toPolygon=q.prototype.l=
function(){var a=this.pos,e=this.w,b=this.h;return new n(new c(a.x,a.y),[new c,new c(e,0),new c(e,b),new c(0,b)])};f.Response=w;w.prototype.clear=w.prototype.clear=function(){this.bInA=this.aInB=!0;this.overlap=Number.MAX_VALUE;return this};for(var m=[],t=0;10>t;t++)m.push(new c);for(var r=[],t=0;5>t;t++)r.push([]);var A=new w,F=(new q(new c,1E-6,1E-6)).l();f.isSeparatingAxis=y;f.pointInCircle=function(a,c){var b=m.pop().c(a).sub(c.pos),h=c.r*c.r,f=b.g();m.push(b);return f<=h};f.pointInPolygon=function(a,
c){F.pos.c(a);A.clear();var b=E(F,c,A);b&&(b=A.aInB);return b};f.testCircleCircle=function(a,c,b){var f=m.pop().c(c.pos).sub(a.pos),l=a.r+c.r,k=f.g();if(k>l*l)return m.push(f),!1;b&&(k=Math.sqrt(k),b.a=a,b.b=c,b.overlap=l-k,b.overlapN.c(f.normalize()),b.overlapV.c(f).scale(b.overlap),b.aInB=a.r<=c.r&&k<=c.r-a.r,b.bInA=c.r<=a.r&&k<=a.r-c.r);m.push(f);return!0};f.testPolygonCircle=D;f.testCirclePolygon=function(a,c,b){if((a=D(c,a,b))&&b){c=b.a;var f=b.aInB;b.overlapN.reverse();b.overlapV.reverse();
b.a=b.b;b.b=c;b.aInB=b.bInA;b.bInA=f}return a};f.testPolygonPolygon=E;return f}"function"===typeof define&&define.amd?define(x):"object"===typeof exports?module.exports=x():this.SAT=x();</script>
<script src="jquery.min.js"></script>
<script>/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

var TWEEN = TWEEN || (function () {

	var _tweens = [];

	return {

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		add: function (tween) {

			_tweens.push(tween);

		},

		remove: function (tween) {

			var i = _tweens.indexOf(tween);

			if (i !== -1) {
				_tweens.splice(i, 1);
			}

		},

		update: function (time, preserve) {

			if (_tweens.length === 0) {
				return false;
			}

			var i = 0;

			time = time !== undefined ? time : TWEEN.now();

			while (i < _tweens.length) {

				if (_tweens[i].update(time) || preserve) {
					i++;
				} else {
					_tweens.splice(i, 1);
				}

			}

			return true;

		}
	};

})();


// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (window) === 'undefined' && typeof (process) !== 'undefined') {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use window.performance.now if it is available.
else if (typeof (window) !== 'undefined' &&
         window.performance !== undefined &&
		 window.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	TWEEN.now = window.performance.now.bind(window.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	TWEEN.now = function () {
		return new Date().getTime();
	};
}


TWEEN.Tween = function (object) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _repeatDelayTime;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	this.to = function (properties, duration) {

		_valuesEnd = properties;

		if (duration !== undefined) {
			_duration = duration;
		}

		return this;

	};

	this.start = function (time) {

		TWEEN.add(this);

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : TWEEN.now();
		_startTime += _delayTime;

		for (var property in _valuesEnd) {

			// Check if an Array was provided as property value
			if (_valuesEnd[property] instanceof Array) {

				if (_valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);

			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (_object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			_valuesStart[property] = _object[property];

			if ((_valuesStart[property] instanceof Array) === false) {
				_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[property] = _valuesStart[property] || 0;

		}

		return this;

	};

	this.stop = function () {

		if (!_isPlaying) {
			return this;
		}

		TWEEN.remove(this);
		_isPlaying = false;

		if (_onStopCallback !== null) {
			_onStopCallback.call(_object, _object);
		}

		this.stopChainedTweens();
		return this;

	};

	this.end = function () {

		this.update(_startTime + _duration);
		return this;

	};

	this.stopChainedTweens = function () {

		for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
			_chainedTweens[i].stop();
		}

	};

	this.delay = function (amount) {

		_delayTime = amount;
		return this;

	};

	this.repeat = function (times) {

		_repeat = times;
		return this;

	};

	this.repeatDelay = function (amount) {

		_repeatDelayTime = amount;
		return this;

	};

	this.yoyo = function (yoyo) {

		_yoyo = yoyo;
		return this;

	};


	this.easing = function (easing) {

		_easingFunction = easing;
		return this;

	};

	this.interpolation = function (interpolation) {

		_interpolationFunction = interpolation;
		return this;

	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;

	};

	this.onStart = function (callback) {

		_onStartCallback = callback;
		return this;

	};

	this.onUpdate = function (callback) {

		_onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function (callback) {

		_onCompleteCallback = callback;
		return this;

	};

	this.onStop = function (callback) {

		_onStopCallback = callback;
		return this;

	};

	this.update = function (time) {

		var property;
		var elapsed;
		var value;

		if (time < _startTime) {
			return true;
		}

		if (_onStartCallbackFired === false) {

			if (_onStartCallback !== null) {
				_onStartCallback.call(_object, _object);
			}

			_onStartCallbackFired = true;
		}

		elapsed = (time - _startTime) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction(elapsed);

		for (property in _valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (_valuesStart[property] === undefined) {
				continue;
			}

			var start = _valuesStart[property] || 0;
			var end = _valuesEnd[property];

			if (end instanceof Array) {

				_object[property] = _interpolationFunction(end, value);

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof (end) === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof (end) === 'number') {
					_object[property] = start + (end - start) * value;
				}

			}

		}

		if (_onUpdateCallback !== null) {
			_onUpdateCallback.call(_object, value);
		}

		if (elapsed === 1) {

			if (_repeat > 0) {

				if (isFinite(_repeat)) {
					_repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in _valuesStartRepeat) {

					if (typeof (_valuesEnd[property]) === 'string') {
						_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[property];

						_valuesStartRepeat[property] = _valuesEnd[property];
						_valuesEnd[property] = tmp;
					}

					_valuesStart[property] = _valuesStartRepeat[property];

				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				if (_repeatDelayTime !== undefined) {
					_startTime = time + _repeatDelayTime;
				} else {
					_startTime = time + _delayTime;
				}

				return true;

			} else {

				if (_onCompleteCallback !== null) {

					_onCompleteCallback.call(_object, _object);
				}

				for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					_chainedTweens[i].start(_startTime + _duration);
				}

				return false;

			}

		}

		return true;

	};

};


TWEEN.Easing = {

	Linear: {

		None: function (k) {

			return k;

		}

	},

	Quadratic: {

		In: function (k) {

			return k * k;

		},

		Out: function (k) {

			return k * (2 - k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return - 0.5 * (--k * (k - 2) - 1);

		}

	},

	Cubic: {

		In: function (k) {

			return k * k * k;

		},

		Out: function (k) {

			return --k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);

		}

	},

	Quartic: {

		In: function (k) {

			return k * k * k * k;

		},

		Out: function (k) {

			return 1 - (--k * k * k * k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return - 0.5 * ((k -= 2) * k * k * k - 2);

		}

	},

	Quintic: {

		In: function (k) {

			return k * k * k * k * k;

		},

		Out: function (k) {

			return --k * k * k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);

		}

	},

	Sinusoidal: {

		In: function (k) {

			return 1 - Math.cos(k * Math.PI / 2);

		},

		Out: function (k) {

			return Math.sin(k * Math.PI / 2);

		},

		InOut: function (k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));

		}

	},

	Exponential: {

		In: function (k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);

		},

		Out: function (k) {

			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

		}

	},

	Circular: {

		In: function (k) {

			return 1 - Math.sqrt(1 - k * k);

		},

		Out: function (k) {

			return Math.sqrt(1 - (--k * k));

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

		},

		Out: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

		}

	},

	Back: {

		In: function (k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);

		},

		Out: function (k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;

		},

		InOut: function (k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

		}

	},

	Bounce: {

		In: function (k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

		},

		Out: function (k) {

			if (k < (1 / 2.75)) {
				return 7.5625 * k * k;
			} else if (k < (2 / 2.75)) {
				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
			} else if (k < (2.5 / 2.75)) {
				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
			} else {
				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
			}

		},

		InOut: function (k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

	},

	Bezier: function (v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;

	},

	CatmullRom: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

		}

	},

	Utils: {

		Linear: function (p0, p1, t) {

			return (p1 - p0) * t + p0;

		},

		Bernstein: function (n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);

		},

		Factorial: (function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;

			};

		})(),

		CatmullRom: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
(function (root) {

	if (typeof define === 'function' && define.amd) {

		// AMD
		define([], function () {
			return TWEEN;
		});

	} else if (typeof module !== 'undefined' && typeof exports === 'object') {

		// Node.js
		module.exports = TWEEN;

	} else if (root !== undefined) {

		// Global variable
		root.TWEEN = TWEEN;

	}

})(this);
</script>
<script>//https://github.com/mattdesl/lerp/blob/master/index.js
var lerp = function (v0, v1, t) { return v0*(1-t)+v1*t; };</script>
<script>/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && !result.msedge && (android || result.silk)) {
      result.android = t
    } else if (!result.windowsphone && !result.msedge && iosdevice) {
      result[iosdevice] = t
      result.ios = t
    } else if (mac) {
      result.mac = t
    } else if (xbox) {
      result.xbox = t
    } else if (windows) {
      result.windows = t
    } else if (linux) {
      result.linux = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});
</script>
<script>/*! howler.js v2.0.9 | (c) 2013-2018, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
!function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._counter=1e3,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var t=this||n;if(e=parseFloat(e),t.ctx||_(),void 0!==e&&e>=0&&e<=1){if(t._volume=e,t._muted)return t;t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e,n.ctx.currentTime);for(var o=0;o<t._howls.length;o++)if(!t._howls[o]._webAudio)for(var r=t._howls[o]._getSoundIds(),a=0;a<r.length;a++){var u=t._howls[o]._soundById(r[a]);u&&u._node&&(u._node.volume=u._volume*e)}return t}return t._volume},mute:function(e){var t=this||n;t.ctx||_(),t._muted=e,t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e?0:t._volume,n.ctx.currentTime);for(var o=0;o<t._howls.length;o++)if(!t._howls[o]._webAudio)for(var r=t._howls[o]._getSoundIds(),a=0;a<r.length;a++){var u=t._howls[o]._soundById(r[a]);u&&u._node&&(u._node.muted=!!e||u._muted)}return t},unload:function(){for(var e=this||n,t=e._howls.length-1;t>=0;t--)e._howls[t].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||"running":"running",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{var t=new Audio;void 0===t.oncanplaythrough&&(e._canPlayEvent="canplay")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var t=new Audio;t.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,t=null;try{t="undefined"!=typeof Audio?new Audio:null}catch(n){return e}if(!t||"function"!=typeof t.canPlayType)return e;var o=t.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),a=r&&parseInt(r[0].split("/")[1],10)<33;return e._codecs={mp3:!(a||!o&&!t.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!o,opus:!!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!t.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),aac:!!t.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!t.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(t.canPlayType("audio/x-m4a;")||t.canPlayType("audio/m4a;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(t.canPlayType("audio/x-mp4;")||t.canPlayType("audio/mp4;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(t.canPlayType("audio/x-flac;")||t.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_enableMobileAudio:function(){var e=this||n,t=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),o=!!("ontouchend"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(t||o)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var r=function(){n._autoResume();var t=e.ctx.createBufferSource();t.buffer=e._scratchBuffer,t.connect(e.ctx.destination),void 0===t.start?t.noteOn(0):t.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),t.onended=function(){t.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener("touchstart",r,!0),document.removeEventListener("touchend",r,!0)}};return document.addEventListener("touchstart",r,!0),document.addEventListener("touchend",r,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&n.usingWebAudio){for(var t=0;t<e._howls.length;t++)if(e._howls[t]._webAudio)for(var o=0;o<e._howls[t]._sounds.length;o++)if(!e._howls[t]._sounds[o]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then(function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())}))},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then(function(){e.state="running";for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,t=function(e){var n=this;if(!e.src||0===e.src.length)return void console.error("An array of source files must be passed with any new Howl.");n.init(e)};t.prototype={init:function(e){var t=this;return n.ctx||_(),t._autoplay=e.autoplay||!1,t._format="string"!=typeof e.format?e.format:[e.format],t._html5=e.html5||!1,t._muted=e.mute||!1,t._loop=e.loop||!1,t._pool=e.pool||5,t._preload="boolean"!=typeof e.preload||e.preload,t._rate=e.rate||1,t._sprite=e.sprite||{},t._src="string"!=typeof e.src?e.src:[e.src],t._volume=void 0!==e.volume?e.volume:1,t._xhrWithCredentials=e.xhrWithCredentials||!1,t._duration=0,t._state="unloaded",t._sounds=[],t._endTimers={},t._queue=[],t._playLock=!1,t._onend=e.onend?[{fn:e.onend}]:[],t._onfade=e.onfade?[{fn:e.onfade}]:[],t._onload=e.onload?[{fn:e.onload}]:[],t._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],t._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],t._onpause=e.onpause?[{fn:e.onpause}]:[],t._onplay=e.onplay?[{fn:e.onplay}]:[],t._onstop=e.onstop?[{fn:e.onstop}]:[],t._onmute=e.onmute?[{fn:e.onmute}]:[],t._onvolume=e.onvolume?[{fn:e.onvolume}]:[],t._onrate=e.onrate?[{fn:e.onrate}]:[],t._onseek=e.onseek?[{fn:e.onseek}]:[],t._onresume=[],t._webAudio=n.usingWebAudio&&!t._html5,void 0!==n.ctx&&n.ctx&&n.mobileAutoEnable&&n._enableMobileAudio(),n._howls.push(t),t._autoplay&&t._queue.push({event:"play",action:function(){t.play()}}),t._preload&&t.load(),t},load:function(){var e=this,t=null;if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");"string"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var u,i;if(e._format&&e._format[r])u=e._format[r];else{if("string"!=typeof(i=e._src[r])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}u=/^data:audio\/([^;,]+);/i.exec(i),u||(u=/\.([^.]+)$/.exec(i.split("?",1)[0])),u&&(u=u[1].toLowerCase())}if(u||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),u&&n.codecs(u)){t=e._src[r];break}}return t?(e._src=t,e._state="loading","https:"===window.location.protocol&&"http:"===t.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new o(e),e._webAudio&&a(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},play:function(e,t){var o=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===o._state&&!o._sprite[e])return null;if(void 0===e){e="__default";for(var a=0,u=0;u<o._sounds.length;u++)o._sounds[u]._paused&&!o._sounds[u]._ended&&(a++,r=o._sounds[u]._id);1===a?e=null:r=null}}var i=r?o._soundById(r):o._inactiveSound();if(!i)return null;if(r&&!e&&(e=i._sprite||"__default"),"loaded"!==o._state){i._sprite=e,i._ended=!1;var d=i._id;return o._queue.push({event:"play",action:function(){o.play(d)}}),d}if(r&&!i._paused)return t||o._loadQueue("play"),i._id;o._webAudio&&n._autoResume();var _=Math.max(0,i._seek>0?i._seek:o._sprite[e][0]/1e3),s=Math.max(0,(o._sprite[e][0]+o._sprite[e][1])/1e3-_),l=1e3*s/Math.abs(i._rate);i._paused=!1,i._ended=!1,i._sprite=e,i._seek=_,i._start=o._sprite[e][0]/1e3,i._stop=(o._sprite[e][0]+o._sprite[e][1])/1e3,i._loop=!(!i._loop&&!o._sprite[e][2]);var c=i._node;if(o._webAudio){var f=function(){o._refreshBuffer(i);var e=i._muted||o._muted?0:i._volume;c.gain.setValueAtTime(e,n.ctx.currentTime),i._playStart=n.ctx.currentTime,void 0===c.bufferSource.start?i._loop?c.bufferSource.noteGrainOn(0,_,86400):c.bufferSource.noteGrainOn(0,_,s):i._loop?c.bufferSource.start(0,_,86400):c.bufferSource.start(0,_,s),l!==1/0&&(o._endTimers[i._id]=setTimeout(o._ended.bind(o,i),l)),t||setTimeout(function(){o._emit("play",i._id)},0)};"running"===n.state?f():(o.once("resume",f),o._clearTimer(i._id))}else{var p=function(){c.currentTime=_,c.muted=i._muted||o._muted||n._muted||c.muted,c.volume=i._volume*n.volume(),c.playbackRate=i._rate;try{var r=c.play();if("undefined"!=typeof Promise&&r instanceof Promise){o._playLock=!0;var a=function(){o._playLock=!1,t||o._emit("play",i._id)};r.then(a,a)}else t||o._emit("play",i._id);if(c.paused)return void o._emit("playerror",i._id,"Playback was unable to start. This is most commonly an issue on mobile devices where playback was not within a user interaction.");"__default"!==e?o._endTimers[i._id]=setTimeout(o._ended.bind(o,i),l):(o._endTimers[i._id]=function(){o._ended(i),c.removeEventListener("ended",o._endTimers[i._id],!1)},c.addEventListener("ended",o._endTimers[i._id],!1))}catch(e){o._emit("playerror",i._id,e)}},m=window&&window.ejecta||!c.readyState&&n._navigator.isCocoonJS;if(c.readyState>=3||m)p();else{var v=function(){p(),c.removeEventListener(n._canPlayEvent,v,!1)};c.addEventListener(n._canPlayEvent,v,!1),o._clearTimer(i._id)}}return i._id},pause:function(e){var n=this;if("loaded"!==n._state||n._playLock)return n._queue.push({event:"pause",action:function(){n.pause(e)}}),n;for(var t=n._getSoundIds(e),o=0;o<t.length;o++){n._clearTimer(t[o]);var r=n._soundById(t[o]);if(r&&!r._paused&&(r._seek=n.seek(t[o]),r._rateSeek=0,r._paused=!0,n._stopFade(t[o]),r._node))if(n._webAudio){if(!r._node.bufferSource)continue;void 0===r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit("pause",r?r._id:null)}return n},stop:function(e,n){var t=this;if("loaded"!==t._state)return t._queue.push({event:"stop",action:function(){t.stop(e)}}),t;for(var o=t._getSoundIds(e),r=0;r<o.length;r++){t._clearTimer(o[r]);var a=t._soundById(o[r]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,t._stopFade(o[r]),a._node&&(t._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),t._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause())),n||t._emit("stop",a._id))}return t},mute:function(e,t){var o=this;if("loaded"!==o._state)return o._queue.push({event:"mute",action:function(){o.mute(e,t)}}),o;if(void 0===t){if("boolean"!=typeof e)return o._muted;o._muted=e}for(var r=o._getSoundIds(t),a=0;a<r.length;a++){var u=o._soundById(r[a]);u&&(u._muted=e,u._interval&&o._stopFade(u._id),o._webAudio&&u._node?u._node.gain.setValueAtTime(e?0:u._volume,n.ctx.currentTime):u._node&&(u._node.muted=!!n._muted||e),o._emit("mute",u._id))}return o},volume:function(){var e,t,o=this,r=arguments;if(0===r.length)return o._volume;if(1===r.length||2===r.length&&void 0===r[1]){o._getSoundIds().indexOf(r[0])>=0?t=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),t=parseInt(r[1],10));var a;if(!(void 0!==e&&e>=0&&e<=1))return a=t?o._soundById(t):o._sounds[0],a?a._volume:0;if("loaded"!==o._state)return o._queue.push({event:"volume",action:function(){o.volume.apply(o,r)}}),o;void 0===t&&(o._volume=e),t=o._getSoundIds(t);for(var u=0;u<t.length;u++)(a=o._soundById(t[u]))&&(a._volume=e,r[2]||o._stopFade(t[u]),o._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),o._emit("volume",a._id));return o},fade:function(e,t,o,r){var a=this;if("loaded"!==a._state)return a._queue.push({event:"fade",action:function(){a.fade(e,t,o,r)}}),a;a.volume(e,r);for(var u=a._getSoundIds(r),i=0;i<u.length;i++){var d=a._soundById(u[i]);if(d){if(r||a._stopFade(u[i]),a._webAudio&&!d._muted){var _=n.ctx.currentTime,s=_+o/1e3;d._volume=e,d._node.gain.setValueAtTime(e,_),d._node.gain.linearRampToValueAtTime(t,s)}a._startFadeInterval(d,e,t,o,u[i],void 0===r)}}return a},_startFadeInterval:function(e,n,t,o,r,a){var u=this,i=n,d=t-n,_=Math.abs(d/.01),s=Math.max(4,_>0?o/_:o),l=Date.now();e._fadeTo=t,e._interval=setInterval(function(){var r=(Date.now()-l)/o;l=Date.now(),i+=d*r,i=Math.max(0,i),i=Math.min(1,i),i=Math.round(100*i)/100,u._webAudio?e._volume=i:u.volume(i,e._id,!0),a&&(u._volume=i),(t<n&&i<=t||t>n&&i>=t)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,u.volume(t,e._id),u._emit("fade",e._id))},s)},_stopFade:function(e){var t=this,o=t._soundById(e);return o&&o._interval&&(t._webAudio&&o._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(o._interval),o._interval=null,t.volume(o._fadeTo,e),o._fadeTo=null,t._emit("fade",e)),t},loop:function(){var e,n,t,o=this,r=arguments;if(0===r.length)return o._loop;if(1===r.length){if("boolean"!=typeof r[0])return!!(t=o._soundById(parseInt(r[0],10)))&&t._loop;e=r[0],o._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var a=o._getSoundIds(n),u=0;u<a.length;u++)(t=o._soundById(a[u]))&&(t._loop=e,o._webAudio&&t._node&&t._node.bufferSource&&(t._node.bufferSource.loop=e,e&&(t._node.bufferSource.loopStart=t._start||0,t._node.bufferSource.loopEnd=t._stop)));return o},rate:function(){var e,t,o=this,r=arguments;if(0===r.length)t=o._sounds[0]._id;else if(1===r.length){var a=o._getSoundIds(),u=a.indexOf(r[0]);u>=0?t=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),t=parseInt(r[1],10));var i;if("number"!=typeof e)return i=o._soundById(t),i?i._rate:o._rate;if("loaded"!==o._state)return o._queue.push({event:"rate",action:function(){o.rate.apply(o,r)}}),o;void 0===t&&(o._rate=e),t=o._getSoundIds(t);for(var d=0;d<t.length;d++)if(i=o._soundById(t[d])){i._rateSeek=o.seek(t[d]),i._playStart=o._webAudio?n.ctx.currentTime:i._playStart,i._rate=e,o._webAudio&&i._node&&i._node.bufferSource?i._node.bufferSource.playbackRate.setValueAtTime(e,n.ctx.currentTime):i._node&&(i._node.playbackRate=e);var _=o.seek(t[d]),s=(o._sprite[i._sprite][0]+o._sprite[i._sprite][1])/1e3-_,l=1e3*s/Math.abs(i._rate);!o._endTimers[t[d]]&&i._paused||(o._clearTimer(t[d]),o._endTimers[t[d]]=setTimeout(o._ended.bind(o,i),l)),o._emit("rate",i._id)}return o},seek:function(){var e,t,o=this,r=arguments;if(0===r.length)t=o._sounds[0]._id;else if(1===r.length){var a=o._getSoundIds(),u=a.indexOf(r[0]);u>=0?t=parseInt(r[0],10):o._sounds.length&&(t=o._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),t=parseInt(r[1],10));if(void 0===t)return o;if("loaded"!==o._state)return o._queue.push({event:"seek",action:function(){o.seek.apply(o,r)}}),o;var i=o._soundById(t);if(i){if(!("number"==typeof e&&e>=0)){if(o._webAudio){var d=o.playing(t)?n.ctx.currentTime-i._playStart:0,_=i._rateSeek?i._rateSeek-i._seek:0;return i._seek+(_+d*Math.abs(i._rate))}return i._node.currentTime}var s=o.playing(t);if(s&&o.pause(t,!0),i._seek=e,i._ended=!1,o._clearTimer(t),s&&o.play(t,!0),!o._webAudio&&i._node&&(i._node.currentTime=e),s&&!o._webAudio){var l=function(){o._playLock?setTimeout(l,0):o._emit("seek",t)};setTimeout(l,0)}else o._emit("seek",t)}return o},playing:function(e){var n=this;if("number"==typeof e){var t=n._soundById(e);return!!t&&!t._paused}for(var o=0;o<n._sounds.length;o++)if(!n._sounds[o]._paused)return!0;return!1},duration:function(e){var n=this,t=n._duration,o=n._soundById(e);return o&&(t=n._sprite[o._sprite][1]/1e3),t},state:function(){return this._state},unload:function(){for(var e=this,t=e._sounds,o=0;o<t.length;o++){if(t[o]._paused||e.stop(t[o]._id),!e._webAudio){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(t[o]._node.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),t[o]._node.removeEventListener("error",t[o]._errorFn,!1),t[o]._node.removeEventListener(n._canPlayEvent,t[o]._loadFn,!1)}delete t[o]._node,e._clearTimer(t[o]._id);var a=n._howls.indexOf(e);a>=0&&n._howls.splice(a,1)}var u=!0;for(o=0;o<n._howls.length;o++)if(n._howls[o]._src===e._src){u=!1;break}return r&&u&&delete r[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,n,t,o){var r=this,a=r["_on"+e];return"function"==typeof n&&a.push(o?{id:t,fn:n,once:o}:{id:t,fn:n}),r},off:function(e,n,t){var o=this,r=o["_on"+e],a=0;if("number"==typeof n&&(t=n,n=null),n||t)for(a=0;a<r.length;a++){var u=t===r[a].id;if(n===r[a].fn&&u||!n&&u){r.splice(a,1);break}}else if(e)o["_on"+e]=[];else{var i=Object.keys(o);for(a=0;a<i.length;a++)0===i[a].indexOf("_on")&&Array.isArray(o[i[a]])&&(o[i[a]]=[])}return o},once:function(e,n,t){var o=this;return o.on(e,n,t,1),o},_emit:function(e,n,t){for(var o=this,r=o["_on"+e],a=r.length-1;a>=0;a--)r[a].id&&r[a].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,t)}.bind(o,r[a].fn),0),r[a].once&&o.off(e,r[a].fn,r[a].id));return o._loadQueue(e),o},_loadQueue:function(e){var n=this;if(n._queue.length>0){var t=n._queue[0];t.event===e&&(n._queue.shift(),n._loadQueue()),e||t.action()}return n},_ended:function(e){var t=this,o=e._sprite;if(!t._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(t._ended.bind(t,e),100),t;var r=!(!e._loop&&!t._sprite[o][2]);if(t._emit("end",e._id),!t._webAudio&&r&&t.stop(e._id,!0).play(e._id),t._webAudio&&r){t._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var a=1e3*(e._stop-e._start)/Math.abs(e._rate);t._endTimers[e._id]=setTimeout(t._ended.bind(t,e),a)}return t._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,t._clearTimer(e._id),t._cleanBuffer(e._node),n._autoSuspend()),t._webAudio||r||t.stop(e._id),t},_clearTimer:function(e){var n=this;if(n._endTimers[e]){if("function"!=typeof n._endTimers[e])clearTimeout(n._endTimers[e]);else{var t=n._soundById(e);t&&t._node&&t._node.removeEventListener("ended",n._endTimers[e],!1)}delete n._endTimers[e]}return n},_soundById:function(e){for(var n=this,t=0;t<n._sounds.length;t++)if(e===n._sounds[t]._id)return n._sounds[t];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new o(e)},_drain:function(){var e=this,n=e._pool,t=0,o=0;if(!(e._sounds.length<n)){for(o=0;o<e._sounds.length;o++)e._sounds[o]._ended&&t++;for(o=e._sounds.length-1;o>=0;o--){if(t<=n)return;e._sounds[o]._ended&&(e._webAudio&&e._sounds[o]._node&&e._sounds[o]._node.disconnect(0),e._sounds.splice(o,1),t--)}}},_getSoundIds:function(e){var n=this;if(void 0===e){for(var t=[],o=0;o<n._sounds.length;o++)t.push(n._sounds[o]._id);return t}return[e]},_refreshBuffer:function(e){var t=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[t._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,n.ctx.currentTime),t},_cleanBuffer:function(e){var t=this;if(n._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}}return e.bufferSource=null,t}};var o=function(e){this._parent=e,this.init()};o.prototype={init:function(){var e=this,t=e._parent;return e._muted=t._muted,e._loop=t._loop,e._volume=t._volume,e._rate=t._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,t._sounds.push(e),e.create(),e},create:function(){var e=this,t=e._parent,o=n._muted||e._muted||e._parent._muted?0:e._volume;return t._webAudio?(e._node=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(o,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):(e._node=new Audio,e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._node.src=t._src,e._node.preload="auto",e._node.volume=o*n.volume(),e._node.load()),e},reset:function(){var e=this,t=e._parent;return e._muted=t._muted,e._loop=t._loop,e._volume=t._volume,e._rate=t._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,t=e._parent;t._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(t._sprite).length&&(t._sprite={__default:[0,1e3*t._duration]}),"loaded"!==t._state&&(t._state="loaded",t._emit("load"),t._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)}};var r={},a=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void d(e);if(/^data:[^;]+;base64,/.test(n)){for(var t=atob(n.split(",")[1]),o=new Uint8Array(t.length),a=0;a<t.length;++a)o[a]=t.charCodeAt(a);i(o.buffer,e)}else{var _=new XMLHttpRequest;_.open("GET",n,!0),_.withCredentials=e._xhrWithCredentials,_.responseType="arraybuffer",_.onload=function(){var n=(_.status+"")[0];if("0"!==n&&"2"!==n&&"3"!==n)return void e._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");i(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},u(_)}},u=function(e){try{e.send()}catch(n){e.onerror()}},i=function(e,t){n.ctx.decodeAudioData(e,function(e){e&&t._sounds.length>0&&(r[t._src]=e,d(t,e))},function(){t._emit("loaderror",null,"Decoding audio data failed.")})},d=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},_=function(){try{"undefined"!=typeof AudioContext?n.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),t=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),o=t?parseInt(t[1],10):null;if(e&&o&&o<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());(n._navigator&&n._navigator.standalone&&!r||n._navigator&&!n._navigator.standalone&&!r)&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:1,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()};"function"==typeof define&&define.amd&&define([],function(){return{Howler:n,Howl:t}}),"undefined"!=typeof exports&&(exports.Howler=n,exports.Howl=t),"undefined"!=typeof window?(window.HowlerGlobal=e,window.Howler=n,window.Howl=t,window.Sound=o):"undefined"!=typeof global&&(global.HowlerGlobal=e,global.Howler=n,global.Howl=t,global.Sound=o)}();
/*! Spatial Plugin */
!function(){"use strict";HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(n){var e=this;if(!e.ctx||!e.ctx.listener)return e;for(var t=e._howls.length-1;t>=0;t--)e._howls[t].stereo(n);return e},HowlerGlobal.prototype.pos=function(n,e,t){var o=this;return o.ctx&&o.ctx.listener?(e="number"!=typeof e?o._pos[1]:e,t="number"!=typeof t?o._pos[2]:t,"number"!=typeof n?o._pos:(o._pos=[n,e,t],o.ctx.listener.setPosition(o._pos[0],o._pos[1],o._pos[2]),o)):o},HowlerGlobal.prototype.orientation=function(n,e,t,o,r,a){var i=this;if(!i.ctx||!i.ctx.listener)return i;var p=i._orientation;return e="number"!=typeof e?p[1]:e,t="number"!=typeof t?p[2]:t,o="number"!=typeof o?p[3]:o,r="number"!=typeof r?p[4]:r,a="number"!=typeof a?p[5]:a,"number"!=typeof n?p:(i._orientation=[n,e,t,o,r,a],i.ctx.listener.setOrientation(n,e,t,o,r,a),i)},Howl.prototype.init=function(n){return function(e){var t=this;return t._orientation=e.orientation||[1,0,0],t._stereo=e.stereo||null,t._pos=e.pos||null,t._pannerAttr={coneInnerAngle:void 0!==e.coneInnerAngle?e.coneInnerAngle:360,coneOuterAngle:void 0!==e.coneOuterAngle?e.coneOuterAngle:360,coneOuterGain:void 0!==e.coneOuterGain?e.coneOuterGain:0,distanceModel:void 0!==e.distanceModel?e.distanceModel:"inverse",maxDistance:void 0!==e.maxDistance?e.maxDistance:1e4,panningModel:void 0!==e.panningModel?e.panningModel:"HRTF",refDistance:void 0!==e.refDistance?e.refDistance:1,rolloffFactor:void 0!==e.rolloffFactor?e.rolloffFactor:1},t._onstereo=e.onstereo?[{fn:e.onstereo}]:[],t._onpos=e.onpos?[{fn:e.onpos}]:[],t._onorientation=e.onorientation?[{fn:e.onorientation}]:[],n.call(this,e)}}(Howl.prototype.init),Howl.prototype.stereo=function(e,t){var o=this;if(!o._webAudio)return o;if("loaded"!==o._state)return o._queue.push({event:"stereo",action:function(){o.stereo(e,t)}}),o;var r=void 0===Howler.ctx.createStereoPanner?"spatial":"stereo";if(void 0===t){if("number"!=typeof e)return o._stereo;o._stereo=e,o._pos=[e,0,0]}for(var a=o._getSoundIds(t),i=0;i<a.length;i++){var p=o._soundById(a[i]);if(p){if("number"!=typeof e)return p._stereo;p._stereo=e,p._pos=[e,0,0],p._node&&(p._pannerAttr.panningModel="equalpower",p._panner&&p._panner.pan||n(p,r),"spatial"===r?p._panner.setPosition(e,0,0):p._panner.pan.setValueAtTime(e,Howler.ctx.currentTime)),o._emit("stereo",p._id)}}return o},Howl.prototype.pos=function(e,t,o,r){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"pos",action:function(){a.pos(e,t,o,r)}}),a;if(t="number"!=typeof t?0:t,o="number"!=typeof o?-.5:o,void 0===r){if("number"!=typeof e)return a._pos;a._pos=[e,t,o]}for(var i=a._getSoundIds(r),p=0;p<i.length;p++){var s=a._soundById(i[p]);if(s){if("number"!=typeof e)return s._pos;s._pos=[e,t,o],s._node&&(s._panner&&!s._panner.pan||n(s,"spatial"),s._panner.setPosition(e,t,o)),a._emit("pos",s._id)}}return a},Howl.prototype.orientation=function(e,t,o,r){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"orientation",action:function(){a.orientation(e,t,o,r)}}),a;if(t="number"!=typeof t?a._orientation[1]:t,o="number"!=typeof o?a._orientation[2]:o,void 0===r){if("number"!=typeof e)return a._orientation;a._orientation=[e,t,o]}for(var i=a._getSoundIds(r),p=0;p<i.length;p++){var s=a._soundById(i[p]);if(s){if("number"!=typeof e)return s._orientation;s._orientation=[e,t,o],s._node&&(s._panner||(s._pos||(s._pos=a._pos||[0,0,-.5]),n(s,"spatial")),s._panner.setOrientation(e,t,o)),a._emit("orientation",s._id)}}return a},Howl.prototype.pannerAttr=function(){var e,t,o,r=this,a=arguments;if(!r._webAudio)return r;if(0===a.length)return r._pannerAttr;if(1===a.length){if("object"!=typeof a[0])return o=r._soundById(parseInt(a[0],10)),o?o._pannerAttr:r._pannerAttr;e=a[0],void 0===t&&(e.pannerAttr||(e.pannerAttr={coneInnerAngle:e.coneInnerAngle,coneOuterAngle:e.coneOuterAngle,coneOuterGain:e.coneOuterGain,distanceModel:e.distanceModel,maxDistance:e.maxDistance,refDistance:e.refDistance,rolloffFactor:e.rolloffFactor,panningModel:e.panningModel}),r._pannerAttr={coneInnerAngle:void 0!==e.pannerAttr.coneInnerAngle?e.pannerAttr.coneInnerAngle:r._coneInnerAngle,coneOuterAngle:void 0!==e.pannerAttr.coneOuterAngle?e.pannerAttr.coneOuterAngle:r._coneOuterAngle,coneOuterGain:void 0!==e.pannerAttr.coneOuterGain?e.pannerAttr.coneOuterGain:r._coneOuterGain,distanceModel:void 0!==e.pannerAttr.distanceModel?e.pannerAttr.distanceModel:r._distanceModel,maxDistance:void 0!==e.pannerAttr.maxDistance?e.pannerAttr.maxDistance:r._maxDistance,refDistance:void 0!==e.pannerAttr.refDistance?e.pannerAttr.refDistance:r._refDistance,rolloffFactor:void 0!==e.pannerAttr.rolloffFactor?e.pannerAttr.rolloffFactor:r._rolloffFactor,panningModel:void 0!==e.pannerAttr.panningModel?e.pannerAttr.panningModel:r._panningModel})}else 2===a.length&&(e=a[0],t=parseInt(a[1],10));for(var i=r._getSoundIds(t),p=0;p<i.length;p++)if(o=r._soundById(i[p])){var s=o._pannerAttr;s={coneInnerAngle:void 0!==e.coneInnerAngle?e.coneInnerAngle:s.coneInnerAngle,coneOuterAngle:void 0!==e.coneOuterAngle?e.coneOuterAngle:s.coneOuterAngle,coneOuterGain:void 0!==e.coneOuterGain?e.coneOuterGain:s.coneOuterGain,distanceModel:void 0!==e.distanceModel?e.distanceModel:s.distanceModel,maxDistance:void 0!==e.maxDistance?e.maxDistance:s.maxDistance,refDistance:void 0!==e.refDistance?e.refDistance:s.refDistance,rolloffFactor:void 0!==e.rolloffFactor?e.rolloffFactor:s.rolloffFactor,panningModel:void 0!==e.panningModel?e.panningModel:s.panningModel};var l=o._panner;l?(l.coneInnerAngle=s.coneInnerAngle,l.coneOuterAngle=s.coneOuterAngle,l.coneOuterGain=s.coneOuterGain,l.distanceModel=s.distanceModel,l.maxDistance=s.maxDistance,l.refDistance=s.refDistance,l.rolloffFactor=s.rolloffFactor,l.panningModel=s.panningModel):(o._pos||(o._pos=r._pos||[0,0,-.5]),n(o,"spatial"))}return r},Sound.prototype.init=function(n){return function(){var e=this,t=e._parent;e._orientation=t._orientation,e._stereo=t._stereo,e._pos=t._pos,e._pannerAttr=t._pannerAttr,n.call(this),e._stereo?t.stereo(e._stereo):e._pos&&t.pos(e._pos[0],e._pos[1],e._pos[2],e._id)}}(Sound.prototype.init),Sound.prototype.reset=function(n){return function(){var e=this,t=e._parent;return e._orientation=t._orientation,e._pos=t._pos,e._pannerAttr=t._pannerAttr,n.call(this)}}(Sound.prototype.reset);var n=function(n,e){e=e||"spatial","spatial"===e?(n._panner=Howler.ctx.createPanner(),n._panner.coneInnerAngle=n._pannerAttr.coneInnerAngle,n._panner.coneOuterAngle=n._pannerAttr.coneOuterAngle,n._panner.coneOuterGain=n._pannerAttr.coneOuterGain,n._panner.distanceModel=n._pannerAttr.distanceModel,n._panner.maxDistance=n._pannerAttr.maxDistance,n._panner.refDistance=n._pannerAttr.refDistance,n._panner.rolloffFactor=n._pannerAttr.rolloffFactor,n._panner.panningModel=n._pannerAttr.panningModel,n._panner.setPosition(n._pos[0],n._pos[1],n._pos[2]),n._panner.setOrientation(n._orientation[0],n._orientation[1],n._orientation[2])):(n._panner=Howler.ctx.createStereoPanner(),n._panner.pan.setValueAtTime(n._stereo,Howler.ctx.currentTime)),n._panner.connect(n._node),n._paused||n._parent.pause(n._id,!0).play(n._id,!0)}}();</script>
<script>var URLParameterUtils = (function () {

	var urlParameterUtils = { };

	urlParameterUtils.getParameterByName = function (name, url) {
	    if (!url) url = window.location.href;
	    name = name.replace(/[\[\]]/g, "\\$&");
	    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
	        results = regex.exec(url);
	    if (!results) return null;
	    if (!results[2]) return '';
	    return decodeURIComponent(results[2].replace(/\+/g, " "));
	}

	//http://stackoverflow.com/questions/1634748/how-can-i-delete-a-query-string-parameter-in-javascript
	urlParameterUtils.clearURLParam = function (parameter) {
	    //prefer to use l.search if you have a location/link object
	    var url = window.location.href;
	    var urlparts= url.split('?');   
	    if (urlparts.length>=2) {

	        var prefix= encodeURIComponent(parameter)+'=';
	        var pars= urlparts[1].split(/[&;]/g);

	        //reverse iteration as may be destructive
	        for (var i= pars.length; i-- > 0;) {    
	            //idiom for string.startsWith
	            if (pars[i].lastIndexOf(prefix, 0) !== -1) {  
	                pars.splice(i, 1);
	            }
	        }

	        url= urlparts[0] + (pars.length > 0 ? '?' + pars.join('&') : "");
	        //console.log(url)
	        //window.location.href = url;
	        history.pushState(null, null, url);
	        return url;
	    } else {
	        return url;
	    }
	}

	return urlParameterUtils;

})();</script>
<script>// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){"object"===typeof exports&&"undefined"!==typeof module?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});
</script>
<script>window.saveData = function (key, data) {
	if(!localStorage.savedData) 
		localStorage.savedData = JSON.stringify({});

	var savedData = JSON.parse(localStorage.savedData)
	var type = typeof data;
	savedData[key] = {
		type: type,
		data: (type === 'object') ? JSON.stringify(data) : data
	};
	localStorage.savedData = JSON.stringify(savedData);
}

window.getData = function (key) {
	var savedData = JSON.parse(localStorage.savedData)
	if(savedData[key] !== undefined) {
		var value = savedData[key];
		if(value.type === 'number') {
			return parseFloat(value.data)
		} else if (value.type === 'string') {
			return value.data;
		} else if (value.type === 'object') {
			return JSON.parse(value.data);
		}
	} else {
		throw (new Error(key + " does not exist in saved data."))
	}
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var tweenValueNames = ["x","y","scaleX","scaleY","rotation","opacity"];

var WickTween = function() {
    this.x = 0;
    this.y = 0; 
    this.z = 0; 
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.opacity = 1;

    this.playheadPosition = 0;
    this.rotations = 0;

    this.uuid = random.uuid4();

    this.tweenType = 'Linear';
    this.tweenDir = 'None';
}

WickTween.fromWickObjectState = function (wickObject) {
	var tween = new WickTween();

	tweenValueNames.forEach(function (name) {
		tween[name] = wickObject[name];
	});

	return tween;
}

WickTween.prototype.copy = function () {
    var copy = new WickTween();

    copy.x = this.x;
    copy.y = this.y; 
    copy.z = this.z; 
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.opacity = this.opacity;

    copy.playheadPosition = this.playheadPosition;
    copy.rotations = this.rotations;

    copy.tweenType = this.tweenType;
    copy.tweenDir = this.tweenDir;

    return copy;
}

WickTween.prototype.updateFromWickObjectState = function (wickObject) {
    var self = this;
    
    tweenValueNames.forEach(function (name) {
        self[name] = wickObject[name];
    });
}

WickTween.prototype.applyTweenToWickObject = function(wickObject) {
	var that = this;

	tweenValueNames.forEach(function (name) {
		wickObject[name] = that[name];
	});
};

WickTween.interpolateTweens = function (tweenA, tweenB, t) {
	var interpTween = new WickTween();

	var tweenFunc = (tweenA.tweenType === "Linear") ? (TWEEN.Easing.Linear.None) : (TWEEN.Easing[tweenA.tweenType][tweenA.tweenDir]);
	tweenValueNames.forEach(function (name) {
		var tt = tweenFunc(t);
        var valA = tweenA[name];
        var valB = tweenB[name];
        if(name === 'rotation') {
            while(valA < -180) valA += 360;
            while(valB < -180) valB += 360;
            while(valA > 180) valA -= 360;
            while(valB > 180) valB -= 360;
            valB += tweenA.rotations * 360;
        }
		interpTween[name] = lerp(valA, valB, tt);
	});

	return interpTween;
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickFrame = function () {
    // Identifier so we can do e.g. movePlayheadTo("menu") 
    this.name = "New Frame";

    // Store all objects in frame. 
    this.wickObjects = [];

    this.tweens = [];

    // All path data of the frame (Stored as SVG)
    this.pathData = null;

    // Where this frame exists on the timeline
    this.playheadPosition = null;

    // Frame length for long frames
    this.length = 1;

    // Should the frame reset on being entered?
    this.alwaysSaveState = false;

    // Generate unique id
    this.uuid = random.uuid4();

    // The layer that this frame belongs to
    this.parentLayer = null;

    // Set script to default
    this.wickScript = "";

    this.audioAssetUUID = null;
};
    
WickFrame.prototype.tick = function () {
    var self = this;
    
    // Inactive -> Inactive
    // Do nothing, frame is still inactive
    if (!this._wasActiveLastTick && !this._active) {

    }
    // Inactive -> Active
    // Frame just became active! It's fresh!
    else if (!this._wasActiveLastTick && this._active) {
        if(this.hasScript()) {
            (wickPlayer || wickEditor).project.initScript(this);
            
            (wickPlayer || wickEditor).project.runScript(this, 'load');
            (wickPlayer || wickEditor).project.runScript(this, 'update');
        }

        if(this.hasSound()) {
            this._wantsToPlaySound = true;
        }
    }
    // Active -> Active
    // Frame is still active!
    else if (this._wasActiveLastTick && this._active) {
        if(this.hasScript()) {
            (wickPlayer || wickEditor).project.runScript(this, 'update');
        }
    }    
    // Active -> Inactive
    // Frame just stopped being active. Clean up!
    else if (this._wasActiveLastTick && !this._active) {
        if(this.hasSound()) {
            this._wantsToStopSound = true;
        }
    }

    if(this.hasScript()) {
        if(this._wasClicked) {
            (wickPlayer || wickEditor).project.runScript(this, 'mousePressed');
            this._wasClicked = false;
        }

        if(this._beingClicked) {
            (wickPlayer || wickEditor).project.runScript(this, 'mouseDown');
        }

        if(this._wasHoveredOver) {
            (wickPlayer || wickEditor).project.runScript(this, 'mouseHover');
            this._wasHoveredOver = false;
        }

        if(this._mouseJustLeft) {
            (wickPlayer || wickEditor).project.runScript(this, 'mouseLeave');
            this._mouseJustLeft = false;
        }

        if(this._wasClickedOff) {
            (wickPlayer || wickEditor).project.runScript(this, 'mouseReleased');
            this._wasClickedOff = false;
        }

        wickPlayer.inputHandler.getAllKeysJustReleased().forEach(function (key) {
            (wickPlayer || wickEditor).project.runScript(self, 'keyReleased', key);
        });

        wickPlayer.inputHandler.getAllKeysJustPressed().forEach(function (key) {
            (wickPlayer || wickEditor).project.runScript(self, 'keyPressed', key);
        });

        wickPlayer.inputHandler.getAllKeysDown().forEach(function (key) {
            (wickPlayer || wickEditor).project.runScript(self, 'keyDown', key);
        });
    }

    this.wickObjects.forEach(function (wickObject) {
        wickObject.tick();
    });
}

WickFrame.prototype.isActive = function () {
    var parent = this.parentLayer.parentWickObject;

    //if(parent.isRoot) console.log(parent.playheadPosition)

    /*console.log("---")
    console.log("ph "+(parent.playheadPosition))
    console.log("s  "+(this.playheadPosition))
    console.log("e  "+(this.playheadPosition+this.length))
    console.log("---")*/

    return parent.playheadPosition >= this.playheadPosition
        && parent.playheadPosition < this.playheadPosition+this.length
        && parent.isActive();
}

WickFrame.prototype.hasScript = function () {
    return this.wickScript !== "";
}

// Extend our frame to encompass more frames. 
WickFrame.prototype.extend = function(length) {
    this.length += length; 
}

// Reduce the number of frames this WickFrame Occupies. 
WickFrame.prototype.shrink = function(length) {
    // Never "shrink" by a negative amount. 
    if (length <= 0) {
        return;
    }

    originalLength = this.length; 
    this.length -= length; 

    // determine and return the actual change in frames. 
    if (this.length <= 0) {
        this.length = 1;
        return originalLength - 1;
    } else {
        return length; 
    }
}

WickFrame.prototype.copy = function () {

    var copiedFrame = new WickFrame();

    copiedFrame.name = this.name;
    copiedFrame.playheadPosition = this.playheadPosition;
    copiedFrame.length = this.length;
    copiedFrame.wickScript = this.wickScript;
    copiedFrame.uuid = random.uuid4();
    copiedFrame.sourceUUID = this.uuid;

    this.wickObjects.forEach(function (wickObject) {
        copiedFrame.wickObjects.push(wickObject.copy());
    })

    this.tweens.forEach(function (tween) {
        copiedFrame.tweens.push(tween.copy());
    })

    return copiedFrame;

}

WickFrame.prototype.remove = function () {
    this.parentLayer.removeFrame(this);
}

WickFrame.prototype.getFramesDistance = function (frame) {
    var A = this;
    var B = frame;

    if(A._beingMoved || B._beingMoved) return false;

    var AStart = A.playheadPosition;
    var AEnd = A.playheadPosition + A.length;

    var BStart = B.playheadPosition;
    var BEnd = B.playheadPosition + B.length;

    var distA = BStart-AEnd;
    var distB = BEnd-AStart;

    return {
        distA: distA,
        distB: distB
    };
}

WickFrame.prototype.touchesFrame = function (frame) {
    var framesDist = this.getFramesDistance(frame);
    return framesDist.distA < 0 && framesDist.distB > 0;
}

WickFrame.prototype.encodeStrings = function () {

    if(this.wickScripts) {
        for (var key in this.wickScripts) {
            this.wickScripts[key] = WickProject.Compressor.encodeString(this.wickScripts[key]);
        }
    }
    if(this.wickScript) {
        this.wickScript = WickProject.Compressor.encodeString(this.wickScript);
    }

    if(this.pathData) this.pathData = WickProject.Compressor.encodeString(this.pathData);

}

WickFrame.prototype.decodeStrings = function () {

    if(this.wickScripts) {
        for (var key in this.wickScripts) {
            this.wickScripts[key] = WickProject.Compressor.decodeString(this.wickScripts[key]);
        }
    }
    if(this.wickScript) {
        this.wickScript = WickProject.Compressor.decodeString(this.wickScript);
    }

    if(this.pathData) this.pathData = WickProject.Compressor.decodeString(this.pathData);

}

WickFrame.prototype.getFrameEnd = function () {
    return this.playheadPosition + this.length; 
}

WickFrame.prototype.getObjectByUUID = function () {

    var foundWickObject;

    this.wickObjects.forEach(function (wickObject) {
        if(wickObject.uuid === uuid) {
            foundWickObject = wickObject;
        }
    });

    return foundWickObject;

}

WickFrame.prototype.getAsJSON = function () {
    this.wickObjects.forEach(function (wickObject) {
        wickObject.encodeStrings();
    });

    var frameJSON = JSON.stringify(this, WickProject.Exporter.JSONReplacerObject);

    this.wickObjects.forEach(function (wickObject) {
        wickObject.decodeStrings();
    });

    return frameJSON;
}

WickFrame.fromJSON = function (frameJSON) {
    var frame = JSON.parse(frameJSON);
    frame.__proto__ = WickFrame.prototype;
    if(frame.tweens) {
        frame.tweens.forEach(function (tween) {
            tween.__proto__ = WickTween.prototype;
        });
    }
    frame.uuid = random.uuid4();
    frame.wickObjects.forEach(function (wickObject) {
        WickObject.addPrototypes(wickObject);
        wickObject.generateParentObjectReferences();
        wickObject.decodeStrings();
        wickObject.uuid = random.uuid4();
    })
    return frame;
}

WickFrame.fromJSONArray = function (jsonArrayObject) {
    var frames = [];

    var framesJSONArray = jsonArrayObject.wickObjectArray;
    framesJSONArray.forEach(function (frameJSON) {
        var newframe = WickFrame.fromJSON(frameJSON)
        frames.push(newframe)
    });

    return frames;
}

WickFrame.prototype.getNextOpenPlayheadPosition = function () {
    return this.parentLayer.getNextOpenPlayheadPosition(this.playheadPosition);
}

WickFrame.prototype.addTween = function (newTween) {
    var self = this;

    var replacedTween = false;
    self.tweens.forEach(function (tween) {
        if (tween.playheadPosition === newTween.playheadPosition) {
            self.tweens[self.tweens.indexOf(tween)] = newTween;
            replacedTween = true;
        }
    });

    if(!replacedTween)
        self.tweens.push(newTween);
}

WickFrame.prototype.removeTween = function (tweenToDelete) {
    var self = this;

    var deleteTweenIndex = null;
    self.tweens.forEach(function (tween) {
        if(deleteTweenIndex) return;
        if (tweenToDelete === tween) {
            deleteTweenIndex = self.tweens.indexOf(tween);
        }
    });

    if(deleteTweenIndex !== null) {
        self.tweens.splice(deleteTweenIndex, 1);
    }
}

WickFrame.prototype.getCurrentTween = function () {
    return this.getTweenAtFrame(this.parentObject.playheadPosition-this.playheadPosition)
}

WickFrame.prototype.getTweenAtPlayheadPosition = function (playheadPosition) {
    var foundTween;
    this.tweens.forEach(function (tween) {
        if(foundTween) return;
        if(tween.playheadPosition === playheadPosition) foundTween = tween;
    })
    return foundTween;
}

WickFrame.prototype.hasTweenAtFrame = function () {
    var playheadPosition = this.parentObject.playheadPosition-this.playheadPosition;

    var foundTween = false
    this.tweens.forEach(function (tween) {
        if(foundTween) return;
        if(tween.playheadPosition === playheadPosition) foundTween = true;
    })
    return foundTween;
}

WickFrame.prototype.getTweenAtFrame = function (playheadPosition) {
    var playheadPosition = this.parentObject.playheadPosition-this.playheadPosition;
    
    var foundTween;
    this.tweens.forEach(function (tween) {
        if(foundTween) return;
        if(tween.playheadPosition === playheadPosition) foundTween = tween;
    })
    return foundTween;
}

WickFrame.prototype.getFromTween = function () {
    var foundTween = null;

    var relativePlayheadPosition = this.parentObject.playheadPosition-this.playheadPosition;

    var seekPlayheadPosition = relativePlayheadPosition;
    while (!foundTween && seekPlayheadPosition >= 0) {
        this.tweens.forEach(function (tween) {
            if(tween.playheadPosition === seekPlayheadPosition) {
                foundTween = tween;
            }
        });
        seekPlayheadPosition--;
    }

    return foundTween;
}

WickFrame.prototype.getToTween = function () {
    var foundTween = null;

    var relativePlayheadPosition = this.parentObject.playheadPosition-this.playheadPosition;

    var seekPlayheadPosition = relativePlayheadPosition;
    var parentFrameLength = this.length;
    while (!foundTween && seekPlayheadPosition < parentFrameLength) {
        this.tweens.forEach(function (tween) {
            if(tween.playheadPosition === seekPlayheadPosition) {
                foundTween = tween;
            }
        });
        seekPlayheadPosition++;
    }

    return foundTween;
}

WickFrame.prototype.applyTween = function () {

    var self = this;

    var tweenToApply;

    if(self.tweens.length === 1) {
        tweenToApply = self.tweens[0];
    } else if (self.tweens.length > 1) {
        var tweenFrom = self.getFromTween();
        var tweenTo = self.getToTween();

        if (tweenFrom && tweenTo) {
            var A = tweenFrom.playheadPosition;
            var B = tweenTo.playheadPosition;
            var L = B-A;
            var P = (this.parentObject.playheadPosition-this.playheadPosition)-A;
            var T = P/L;
            if(B-A === 0) T = 1;
            
            tweenToApply = WickTween.interpolateTweens(tweenFrom, tweenTo, T);
        }
        if (!tweenFrom && tweenTo) {
            tweenToApply = tweenTo;
        }
        if (!tweenTo && tweenFrom) {
            tweenToApply = tweenFrom;
        }
    }

    if(!tweenToApply) return;
    self.wickObjects.forEach(function (wickObject) {
        tweenToApply.applyTweenToWickObject(wickObject);
    });

}

WickFrame.prototype.hasSound = function () {
    return this.audioAssetUUID;
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickLayer = function () {
    this.frames = [new WickFrame()];
    this.frames[0].playheadPosition = 0;

    this.identifier = "Layer 1"
    this.locked = false;
    this.hidden = false;

    this.parentWickObject = null; // The WickObject that this layer belongs to
};

WickLayer.prototype.getTotalLength = function () {
    var length = 0;

    this.frames.forEach(function (frame) {
        var frameEnd = frame.playheadPosition + frame.length;
        if(frameEnd > length) length = frameEnd;
    });

    return length;
}

WickLayer.prototype.getFrameAtPlayheadPosition = function (playheadPosition) {
    var foundFrame = null;

    this.frames.forEach(function (frame) {
        if(foundFrame) return;
        if(playheadPosition >= frame.playheadPosition && playheadPosition < frame.playheadPosition+frame.length) {
            foundFrame = frame;
        }
    });

    return foundFrame;
}

WickLayer.prototype.getCurrentFrame = function () {
    return this.getFrameAtPlayheadPosition(this.parentWickObject.playheadPosition);
}


WickLayer.prototype.addFrame = function(newFrame) {
    this.frames.push(newFrame);
}

WickLayer.prototype.removeFrame = function(frame) {
    var i = this.frames.indexOf(frame);
    this.frames.splice(i, 1);
}

WickLayer.prototype.copy = function () {

    var copiedLayer = new WickLayer();
    copiedLayer.frames = [];

    this.frames.forEach(function (frame) {
        copiedLayer.frames.push(frame.copy());
    })

    return copiedLayer;

}

WickLayer.prototype.getFrameByIdentifier = function (id) {

    var foundFrame = null;

    this.frames.forEach(function (frame) {
        if(frame.identifier === id) {
            foundFrame = frame;
        }
    });

    return foundFrame;

}

WickLayer.prototype.getRelativePlayheadPosition = function (wickObj, args) {

    var playheadRelativePosition = this.playheadPosition - wickObj.parentFrame.playheadPosition;

    if(args && args.normalized) playheadRelativePosition /= wickObj.parentFrame.length-1;

    return playheadRelativePosition;

}

WickLayer.prototype.getFramesAtPlayheadPosition = function(pos, args) {
    var frames = [];

    var counter = 0;
    for(var f = 0; f < this.frames.length; f++) {
        var frame = this.frames[f];
        for(var i = 0; i < frame.length; i++) {
            if(counter == pos) {
                frames.push(frame);
            }
            counter++;
        }
    }

    return frames;
}

WickLayer.prototype.getNextOpenPlayheadPosition = function (startPosition) {
    var targetPosition = startPosition;

    while(this.getFrameAtPlayheadPosition(targetPosition)) {
        targetPosition ++;
    }

    return targetPosition;
}

WickLayer.prototype.getLastFrame = function (playheadPosition) {
    var lastFrame = null;

    if(!playheadPosition) playheadPosition = 0;

    // Look backwards
    this.frames.forEach(function (frame) {
        if(!lastFrame) lastFrame = frame;
        if(frame.playheadPosition > lastFrame.playheadPosition && frame.playheadPosition < playheadPosition) {
            lastFrame = frame;
        }
    });

    if(lastFrame.playheadPosition > playheadPosition) return null;

    return lastFrame;
}

WickLayer.prototype.containsWickObject = function (o) {
    
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickObject = function () {

// Internals

    // Unique id
    this.uuid = random.uuid4();

    // Name is optional, added by user
    this.name = undefined;

// Positioning

    this.x = 0;
    this.y = 0;
    this.width = undefined;
    this.height = undefined;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.flipX = false;
    this.flipY = false;
    this.opacity = 1;

// Common
    
    //this.wickScript = "function load() {\n\t\n}\n\nfunction update() {\n\t\n}\n";
    this.wickScript = "";

// Static

    this.assetUUID = null;
    this.loop = false;

// Text

    this.isText = false;

// Images

    this.isImage = false;

// Symbols

    this.isSymbol = false;
    this.isButton = false;
    this.isGroup = false;

    // Used to keep track of what frame is being edited
    this.playheadPosition = null;
    this.currentLayer = null;

    // List of layers, only used by symbols
    this.layers = undefined;

// Render
    
    this._renderDirty = false;  // Tell the renderer if this object has changed. 

};

WickObject.fromJSON = function (jsonString) {
    // Parse JSON
    var newWickObject = JSON.parse(jsonString);

    // Put prototypes back on object ('class methods'), they don't get JSONified on project export.
    WickObject.addPrototypes(newWickObject);

    // Decode scripts back to human-readble and eval()-able format
    newWickObject.decodeStrings();

    return newWickObject;
}

WickObject.fromJSONArray = function (jsonArrayObject) {
    var newWickObjects = [];

    var wickObjectJSONArray = jsonArrayObject.wickObjectArray;
    for (var i = 0; i < wickObjectJSONArray.length; i++) {
        
        var newWickObject = WickObject.fromJSON(wickObjectJSONArray[i]);
        
        if(wickObjectJSONArray.length > 1) {
            newWickObject.x += jsonArrayObject.groupPosition.x;
            newWickObject.y += jsonArrayObject.groupPosition.y;
        }

        newWickObjects.push(newWickObject);
    }

    return newWickObjects;
}

WickObject.createPathObject = function (svg) {
    var obj = new WickObject();
    obj.isPath = true;
    obj.pathData = svg;

    return obj;
}

WickObject.createTextObject = function (text) {
    var obj = new WickObject();

    obj.isText = true;
    obj.width = 400;
    obj.textData = {
        fontFamily: 'Arial',
        fontSize: 40,
        fontStyle: 'normal',
        fontWeight: 'normal',
        lineHeight: 1.0,
        fill: '#000000',
        textAlign: 'left',
        text: text
    };

    return obj;
}

WickObject.createNewSymbol = function (name) {

    var symbol = new WickObject();

    symbol.isSymbol = true;
    symbol.playheadPosition = 0;
    symbol.currentLayer = 0;
    symbol.layers = [new WickLayer()];
    symbol.name = name;

    return symbol;

}

// Create a new symbol and add every object in wickObjects as children
WickObject.createSymbolFromWickObjects = function (wickObjects) {

    var symbol = WickObject.createNewSymbol();

    // Calculate center of all WickObjects
    var topLeft = {x:Number.MAX_SAFE_INTEGER, y:Number.MAX_SAFE_INTEGER};
    var bottomRight = {x:-Number.MAX_SAFE_INTEGER,y:-Number.MAX_SAFE_INTEGER};
    wickObjects.forEach(function (wickObj) {
        topLeft.x = Math.min(topLeft.x, wickObj.x - wickObj.width /2);
        topLeft.y = Math.min(topLeft.y, wickObj.y - wickObj.height/2);
        bottomRight.x = Math.max(bottomRight.x, wickObj.x + wickObj.width /2);
        bottomRight.y = Math.max(bottomRight.y, wickObj.y + wickObj.height/2);
    });

    var center = {
        x: topLeft.x + (bottomRight.x - topLeft.x)/2,
        y: topLeft.y + (bottomRight.y - topLeft.y)/2
    }
    symbol.x = center.x;
    symbol.y = center.y;

    var firstFrame = symbol.layers[0].frames[0];
    for(var i = 0; i < wickObjects.length; i++) {
        firstFrame.wickObjects[i] = wickObjects[i];

        firstFrame.wickObjects[i].x = wickObjects[i].x - symbol.x;
        firstFrame.wickObjects[i].y = wickObjects[i].y - symbol.y;
    }

    symbol.width  = firstFrame.wickObjects[0].width;
    symbol.height = firstFrame.wickObjects[0].height;

    return symbol;

}

WickObject.prototype.copy = function () {

    var copiedObject = new WickObject();

    copiedObject.name = this.name;
    copiedObject.x = this.x;
    copiedObject.y = this.y;
    copiedObject.width = this.width;
    copiedObject.height = this.height;
    copiedObject.scaleX = this.scaleX;
    copiedObject.scaleY = this.scaleY;
    copiedObject.rotation = this.rotation;
    copiedObject.flipX = this.flipX;
    copiedObject.flipY = this.flipY;
    copiedObject.opacity = this.opacity;
    copiedObject.uuid = random.uuid4();
    copiedObject.sourceUUID = this.uuid;
    copiedObject.assetUUID = this.assetUUID;
    copiedObject.svgX = this.svgX;
    copiedObject.svgY = this.svgY;
    copiedObject.pathData = this.pathData;
    copiedObject.isImage = this.isImage;
    copiedObject.isPath = this.isPath;
    copiedObject.isText = this.isText;
    copiedObject.isButton = this.isButton;
    copiedObject.isGroup = this.isGroup;
    copiedObject.cachedAbsolutePosition = this.getAbsolutePosition();
    copiedObject.svgStrokeWidth = this.svgStrokeWidth;

    if(this.isText)
        copiedObject.textData = JSON.parse(JSON.stringify(this.textData));

    copiedObject.wickScript = this.wickScript

    if(this.isSymbol) {
        copiedObject.isSymbol = true;

        copiedObject.playheadPosition = 0;
        copiedObject.currentLayer = 0;

        copiedObject.layers = [];
        this.layers.forEach(function (layer) {
            copiedObject.layers.push(layer.copy());
        });
    } else {
        copiedObject.isSymbol = false;
    }

    return copiedObject;

}

WickObject.prototype.getAsJSON = function () {
    var oldX = this.x;
    var oldY = this.y;

    var absPos = this.getAbsolutePosition();
    this.x = absPos.x;
    this.y = absPos.y;

    // Encode scripts to avoid JSON format problems
    this.encodeStrings();

    var JSONWickObject = JSON.stringify(this, WickProject.Exporter.JSONReplacerObject);

    // Put prototypes back on object ('class methods'), they don't get JSONified on project export.
    WickObject.addPrototypes(this);

    // Decode scripts back to human-readble and eval()-able format
    this.decodeStrings();

    this.x = oldX;
    this.y = oldY;

    return JSONWickObject;
}

WickObject.prototype.downloadAsFile = function () {

    var filename = this.name || "wickobject";

    if(this.isSymbol) {
        var blob = new Blob([this.getAsJSON()], {type: "text/plain;charset=utf-8"});
        saveAs(blob, filename+".json");
        return;
    }

    var asset = wickEditor.project.library.getAsset(this.assetUUID);

    if(asset.type === 'image') {
        var ext = asset.getData().split("/")[1].split(';')[0];
        saveAs(dataURItoBlob(asset.getData()), filename+"."+ext);
        return;
    }

    console.error("export not supported for this type of wickobject yet");

}

WickObject.addPrototypes = function (obj) {

    // Put the prototype back on this object
    obj.__proto__ = WickObject.prototype;

    if(obj.isSymbol) {
        obj.layers.forEach(function (layer) {
            layer.__proto__ = WickLayer.prototype;
            layer.frames.forEach(function(frame) {
                frame.__proto__ = WickFrame.prototype;

                if(frame.tweens) {
                    frame.tweens.forEach(function (tween) {
                        tween.__proto__ = WickTween.prototype;
                    });
                }
            });
        });

        obj.getAllChildObjects().forEach(function(currObj) {
            WickObject.addPrototypes(currObj);
        });
    }
}

/* Encodes scripts and strings to avoid JSON format problems */
WickObject.prototype.encodeStrings = function () {

    if(this.wickScript) {
        this.wickScript = WickProject.Compressor.encodeString(this.wickScript);
    }

    if(this.textData) {
        this.textData.text = WickProject.Compressor.encodeString(this.textData.text);
    }

    if(this.pathData) {
        this.pathData = WickProject.Compressor.encodeString(this.pathData);
    }

    if(this.isSymbol) {
        this.getAllFrames().forEach(function (frame) {
            frame.encodeStrings();
        });

        this.getAllChildObjects().forEach(function(child) {
            child.encodeStrings();
        });
    }

}

/* Decodes scripts and strings back to human-readble and eval()-able format */
WickObject.prototype.decodeStrings = function () {
    
    if(this.wickScript) {
        this.wickScript = WickProject.Compressor.decodeString(this.wickScript);
    }

    if(this.textData) {
        this.textData.text = WickProject.Compressor.decodeString(this.textData.text);
    }

    if(this.pathData) {
        this.pathData = WickProject.Compressor.decodeString(this.pathData);
    }

    if(this.isSymbol) {
        this.getAllFrames().forEach(function (frame) {
            frame.decodeStrings();
        });

        this.getAllChildObjects().forEach(function(child) {
            child.decodeStrings();
        });
    }

}

WickObject.prototype.generateParentObjectReferences = function() {

    var self = this;

    if(!self.isSymbol) return;

    self.layers.forEach(function (layer) {
        layer.parentWickObject = self;

        layer.frames.forEach(function (frame) {
            frame.parentLayer = layer;
            frame.parentObject = self;

            frame.wickObjects.forEach(function (wickObject) {
                wickObject.parentObject = self;
                wickObject.parentFrame = frame;

                wickObject.generateParentObjectReferences();
            });
        });
    });

}

WickObject.prototype.generateObjectNameReferences = function () {

    var that = this;

    this.getAllChildObjects().forEach(function(child) {
        that[child.name] = child;

        if(child.isSymbol) {
            child.generateObjectNameReferences();
        }
    });
    this.getAllActiveChildObjects().forEach(function(child) {
        that[child.name] = child;
    });

}

WickObject.prototype.getCurrentLayer = function() {
    return this.layers[this.currentLayer];
}

WickObject.prototype.addLayer = function (layer) {
    var currentLayerNum = 0;

    this.layers.forEach(function (layer) {
        var splitName = layer.identifier.split("Layer ")
        if(splitName && splitName.length > 1) {
            layerNum = parseInt(splitName[1]);
            if(layerNum > currentLayerNum) {
                currentLayerNum = layerNum;
            }
        }
    });

    layer.identifier = "Layer " + (currentLayerNum+1);

    this.layers.push(layer);
}

WickObject.prototype.removeLayer = function (layer) {
    var that = this;
    this.layers.forEach(function (currLayer) {
        if(layer === currLayer) {
            that.layers.splice(that.layers.indexOf(layer), 1);
        }
    });
}

WickObject.prototype.getTotalTimelineLength = function () {
    var longestLayerLength = 0;

    this.layers.forEach(function (layer) {
        var layerLength = layer.getTotalLength();
        if(layerLength > longestLayerLength) {
            longestLayerLength = layerLength;
        }
    });

    return longestLayerLength;

}

WickObject.prototype.updateFrameTween = function (relativePlayheadPosition) {
    var frame = this.parentFrame;
    var tween = frame.getTweenAtFrame(relativePlayheadPosition);

    if(tween) {
        tween.updateFromWickObjectState(this);
    }
}

WickObject.prototype.getActiveFrames = function () {
    if(!this.isSymbol) {
        return [];
    }
    
    var activeFrames = [];

    this.layers.forEach(function (layer) {
        var frame = layer.getCurrentFrame();
        if(frame)
            activeFrames.push(frame);
    });

    return activeFrames;
}

/* Return all child objects of a parent object */
WickObject.prototype.getAllChildObjects = function () {

    if (!this.isSymbol) {
        return [];
    }

    var children = [];
    for(var l = this.layers.length-1; l >= 0; l--) {
        var layer = this.layers[l];
        for(var f = 0; f < layer.frames.length; f++) {
            var frame = layer.frames[f];
            for(var o = 0; o < frame.wickObjects.length; o++) {
                children.push(frame.wickObjects[o]);
            }
        }
    }
    return children;
}

/* Return all child objects in the parent objects current frame. */
WickObject.prototype.getAllActiveChildObjects = function () {

    if (!this.isSymbol) {
        return [];
    }

    var children = [];
    for (var l = this.layers.length-1; l >= 0; l--) {
        var layer = this.layers[l];
        var frame = layer.getFrameAtPlayheadPosition(this.playheadPosition);
        if(frame) {
            frame.wickObjects.forEach(function (obj) {
                children.push(obj);
            });
        }
    }
    return children;
}

/* Return all child objects of a parent object (and their children) */
WickObject.prototype.getAllChildObjectsRecursive = function () {

    if (!this.isSymbol) {
        return [this];
    }

    var children = [this];
    this.layers.forEachBackwards(function (layer) {
        layer.frames.forEach(function (frame) {
            frame.wickObjects.forEach(function (wickObject) {
                children = children.concat(wickObject.getAllChildObjectsRecursive());
            });
        });
    });
    return children;
}

/* Return all active child objects of a parent object (and their children) */
WickObject.prototype.getAllActiveChildObjectsRecursive = function (includeParents) {

    if (!this.isSymbol) {
        return [];
    }

    var children = [];
    for (var l = this.layers.length-1; l >= 0; l--) {
        var frame = this.layers[l].getFrameAtPlayheadPosition(this.playheadPosition);
        if(frame) {
            for(var o = 0; o < frame.wickObjects.length; o++) {
                var obj = frame.wickObjects[o];
                if(includeParents || !obj.isSymbol) children.push(obj);
                children = children.concat(obj.getAllActiveChildObjectsRecursive(includeParents));
            }
        }
    }
    return children;

}

/* Return all child objects in the parent objects current layer. */
WickObject.prototype.getAllActiveLayerChildObjects = function () {

    if (!this.isSymbol) {
        return [];
    }

    var children = [];
    var layer = this.getCurrentLayer();
    var frame = layer.getFrameAtPlayheadPosition(this.playheadPosition);
    if(frame) {
        frame.wickObjects.forEach(function (obj) {
            children.push(obj);
        });
    }
    return children;
}

// Use this to get objects on other layers
WickObject.prototype.getAllInactiveSiblings = function () {

    if(!this.parentObject) {
        return [];
    }

    var that = this;
    var siblings = [];
    this.parentObject.getAllActiveChildObjects().forEach(function (child) {
        if(child !== that) {
            siblings.push(child);
        }
    });
    siblings = siblings.concat(this.parentObject.getAllInactiveSiblings());

    return siblings;

}

// Use this for onion skinning
WickObject.prototype.getNearbyObjects = function (numFramesBack, numFramesForward) {

    // Get nearby frames

    var nearbyFrames = [];

    var startPlayheadPosition = Math.max(0, this.playheadPosition - numFramesBack);
    var endPlayheadPosition = this.playheadPosition + numFramesForward;
    var tempPlayheadPosition = startPlayheadPosition;

    while(tempPlayheadPosition <= endPlayheadPosition) {
        var frame = this.getCurrentLayer().getFrameAtPlayheadPosition(tempPlayheadPosition);

        if(frame && tempPlayheadPosition !== this.playheadPosition && nearbyFrames.indexOf(frame) == -1) {
            nearbyFrames.push(frame);
        }
        
        tempPlayheadPosition ++;
    }

    // Get objects in nearby frames

    var nearbyObjects = [];

    nearbyFrames.forEach(function(frame) {
        nearbyObjects = nearbyObjects.concat(frame.wickObjects);
    });

    return nearbyObjects;

}

//
WickObject.prototype.getObjectsOnFirstFrame = function () {

    var objectsOnFirstFrame = [];

    this.layers.forEach(function (layer) {
        layer.frames[0].wickObjects.forEach(function (wickObj) {
            objectsOnFirstFrame.push(wickObj);
        });
    });

    return objectsOnFirstFrame;

}

WickObject.prototype.getParents = function () {
    if(!this.isSymbol) {
        return [];
    } else if(this.isRoot) {
        return [this];
    } else {
        return this.parentObject.getParents().concat([this]);
    }
}

/* Excludes children of children */
WickObject.prototype.getTotalNumChildren = function () {
    var count = 0;
    for(var l = 0; l < this.layers.length; l++) {
        for(var f = 0; f < this.layers[l].frames.length; f++) {
            for(var o = 0; o < this.layers[l].frames[f].wickObjects.length; o++) {
                count++;
            }
        }
    }
    return count;
}

WickObject.prototype.getAllFrames = function () {

    if(!this.isSymbol) return [];

    var allFrames = [];

    this.layers.forEach(function (layer) {
        layer.frames.forEach(function (frame) {
            allFrames.push(frame);
        });
    });

    return allFrames;
}

WickObject.prototype.getAllFramesWithSound = function () {
    return this.getAllFrames().filter(function (frame) {
        return frame.hasSound();
    });
}

WickObject.prototype.getFrameWithChild = function (child) {

    var foundFrame = null;

    this.layers.forEach(function (layer) {
        layer.frames.forEach(function (frame) {
            frame.wickObjects.forEach(function (wickObject) {
                if(wickObject.uuid === child.uuid) {
                    foundFrame = frame;
                }
            });
        });
    });

    return foundFrame;
}

WickObject.prototype.getLayerWithChild = function (child) {

    var foundLayer = null;

    this.layers.forEach(function (layer) {
        layer.frames.forEach(function (frame) {
            if(frame.wickObjects.indexOf(child) !== -1) {
                foundLayer = layer;
            }
        });
    });

    return foundLayer;
}

WickObject.prototype.remove = function () {
    this.parentObject.removeChild(this);
}

WickObject.prototype.removeChild = function (childToRemove) {

    if(!this.isSymbol) {
        return;
    }

    var that = this;
    this.getAllChildObjects().forEach(function(child) {
        if(child == childToRemove) {
            var index = child.parentFrame.wickObjects.indexOf(child);
            child.parentFrame.wickObjects.splice(index, 1);
        }
    });
}

WickObject.prototype.getZIndex = function () {
    return this.parentFrame.wickObjects.indexOf(this);
}

/* Get the absolute position of this object (the position not relative to the parents) */
WickObject.prototype.getAbsolutePosition = function () {
    if(this.isRoot) {
        return {
            x: this.x,
            y: this.y
        };
    } else if (!this.parentObject) {
        return this.cachedAbsolutePosition;
    } else {
        var parent = this.parentObject;
        var parentPosition = parent.getAbsolutePosition();
        return {
            x: this.x + parentPosition.x,
            y: this.y + parentPosition.y
        };
    }
}

/* Get the absolute position of this object taking into account the scale of the parent */
WickObject.prototype.getAbsolutePositionTransformed = function () {
    if(this.isRoot) {
        return {
            x: this.x,
            y: this.y
        };
    } else {
        var parent = this.parentObject;
        var parentPosition = parent.getAbsolutePositionTransformed();
        var parentScale = parent.getAbsoluteScale()
        var parentFlip = parent.getAbsoluteFlip();
        var rotatedPosition = {x:this.x*parentScale.x, y:this.y*parentScale.y};
        if(parentFlip.x) rotatedPosition.x *= -1;
        if(parentFlip.y) rotatedPosition.y *= -1;
        rotatedPosition = rotate_point(rotatedPosition.x, rotatedPosition.y, 0, 0, parent.getAbsoluteRotation());
        return {
            x: rotatedPosition.x + parentPosition.x,
            y: rotatedPosition.y + parentPosition.y
        };
    }
}

WickObject.prototype.getAbsoluteScale = function () {
    if(this.isRoot) {
        return {
            x: this.scaleX,
            y: this.scaleY
        };
    } else {
        var parentScale = this.parentObject.getAbsoluteScale();
        return {
            x: this.scaleX * parentScale.x,
            y: this.scaleY * parentScale.y
        };
    }
}

WickObject.prototype.getAbsoluteRotation = function () {
    if(this.isRoot) {
        return this.rotation;
    } else {
        var parentRotation = this.parentObject.getAbsoluteRotation();
        return this.rotation + parentRotation;
    }
}

WickObject.prototype.getAbsoluteOpacity = function () {
    if(this.isRoot) {
        return this.opacity;
    } else {
        var parentOpacity = this.parentObject.getAbsoluteOpacity();
        return this.opacity * parentOpacity;
    }
}

WickObject.prototype.getAbsoluteFlip = function () {
    if(this.isRoot) {
        return {
            x: this.flipX,
            y: this.flipY
        };
    } else {
        var parentFlip = this.parentObject.getAbsoluteFlip();
        return {
            x: this.flipX !== parentFlip.x,
            y: this.flipY !== parentFlip.y
        };
    }
}

WickObject.prototype.getAbsoluteTransformations = function () {
    return {
        position: this.getAbsolutePositionTransformed(),
        scale: this.getAbsoluteScale(),
        rotation: this.getAbsoluteRotation(),
        opacity: this.getAbsoluteOpacity(),
        flip: this.getAbsoluteFlip(),
    }
}

WickObject.prototype.isOnActiveLayer = function (activeLayer) {

    return this.parentFrame.parentLayer === activeLayer;

}

WickObject.prototype.play = function () {

    this._playing = true;
}

WickObject.prototype.stop = function () {

    this._playing = false;
}

WickObject.prototype.getFrameById = function (identifier) {
    var foundFrame = null;

    this.getAllFrames().forEach(function (frame) {
        if(frame.name === identifier) {
            foundFrame = frame;
        }
    });

    return foundFrame;
}

WickObject.prototype.getFrameByPlayheadPosition = function (php) {
    var foundFrame = null;

    this.getAllFrames().forEach(function (frame) {
        if(frame.playheadPosition === php) {
            foundFrame = frame;
        }
    });

    return foundFrame;
}


WickObject.prototype.gotoAndStop = function (frame) {
    this.movePlayheadTo(frame);
    this.stop();
}

WickObject.prototype.gotoAndPlay = function (frame) {
    this.movePlayheadTo(frame);
    this.play();
}

WickObject.prototype.movePlayheadTo = function (frame) {

    var oldFrame = this.getCurrentLayer().getCurrentFrame();

    // Frames are zero-indexed internally but start at one in the editor GUI, so you gotta subtract 1.
    if (typeof frame === 'number') {
        var actualFrame = frame-1;

        var endOfFrames = this.getFramesEnd(); 
        // Only navigate to an integer frame if it is nonnegative and a valid frame
        if(actualFrame < endOfFrames) {
            this._newPlayheadPosition = actualFrame;
        } else {
            throw (new Error("Failed to navigate to frame \'" + actualFrame + "\': is not a valid frame."));
        }

    } else if (typeof frame === 'string') {

        var foundFrame = this.getFrameById(frame)

        if (foundFrame) {
            if(this.playheadPosition < foundFrame.playheadPosition || this.playheadPosition >= foundFrame.playheadPosition+foundFrame.length-1) {
                this._newPlayheadPosition = foundFrame.playheadPosition;
            }
        } else {
            throw (new Error("Failed to navigate to frame. \'" + frame + "\' is not a valid frame."));
        }

    }

}

WickObject.prototype.gotoNextFrame = function () {

    var nextFramePos = this.playheadPosition+1;
    var totalLength = this.getTotalTimelineLength();
    if(nextFramePos >= totalLength) {
        nextFramePos = 0;
    }

    this._newPlayheadPosition = nextFramePos;

}

WickObject.prototype.gotoPrevFrame = function () {

    var nextFramePos = this.playheadPosition-1;
    if(nextFramePos < 0) {
        nextFramePos = this.layers[this.currentLayer].getTotalLength()-1;
    }

    this._newPlayheadPosition = nextFramePos;

}

WickObject.prototype.getFramesEnd = function() {
    endFrame = 0; 

    this.layers.forEach(function (layer) {
        layer.frames.forEach( function (frame) {
            endFrame = Math.max (frame.getFrameEnd(), endFrame); 
        })
    });

    return endFrame;

}

WickObject.prototype.hitTest = function (otherObj) {
    this.regenBounds();
    otherObj.regenBounds();

    return intersectRect(this.bounds, otherObj.bounds);
}

WickObject.prototype.regenBounds = function () {
    var self = this;
    if(this.isSymbol) {
        this.bounds = {
            left: Infinity,
            right: -Infinity,
            top: Infinity,
            bottom: -Infinity,
        }
        this.getAllActiveChildObjects().forEach(function (child) {
            child.regenBounds();
            self.bounds.left = Math.min(child.bounds.left, self.bounds.left)
            self.bounds.right = Math.max(child.bounds.right, self.bounds.right)
            self.bounds.top = Math.min(child.bounds.top, self.bounds.top)
            self.bounds.bottom = Math.max(child.bounds.bottom, self.bounds.bottom)
        });
    } else {
        var absPos = this.getAbsolutePosition();
        this.bounds = {
            left: absPos.x - this.width/2,
            right: absPos.x + this.width/2,
            top: absPos.y - this.height/2,
            bottom: absPos.y + this.height/2,
        };
    }
}

WickObject.prototype.isPointInside = function(point) {

    var objects = this.getAllActiveChildObjectsRecursive(false);
    if(!this.isSymbol) {
        objects.push(this);
    }

    var hit = false;

    objects.forEach(function(object) {
        if(hit) return;

        var transformedPosition = object.getAbsolutePositionTransformed();
        var transformedPoint = {x:point.x, y:point.y};
        var transformedScale = object.getAbsoluteScale();
        var transformedWidth = (object.width+object.svgStrokeWidth)*transformedScale.x;
        var transformedHeight = (object.height+object.svgStrokeWidth)*transformedScale.y;

        transformedPoint = rotate_point(
            transformedPoint.x, 
            transformedPoint.y, 
            transformedPosition.x, 
            transformedPosition.y,
            -object.getAbsoluteRotation()
        );

        // Bounding box check
        if ( transformedPoint.x >= transformedPosition.x - transformedWidth /2 &&
             transformedPoint.y >= transformedPosition.y - transformedHeight/2 &&
             transformedPoint.x <= transformedPosition.x + transformedWidth /2 &&
             transformedPoint.y <= transformedPosition.y + transformedHeight/2 ) {

            if(!object.alphaMask) {
                hit = true;
                return;
            }

            var relativePoint = {
                x: transformedPoint.x - transformedPosition.x + transformedWidth /2,
                y: transformedPoint.y - transformedPosition.y + transformedHeight/2
            }

            // Alpha mask check
            var objectAlphaMaskIndex =
                (Math.floor(relativePoint.x/transformedScale.x)%Math.floor(object.width+object.svgStrokeWidth)) +
                (Math.floor(relativePoint.y/transformedScale.y)*Math.floor(object.width+object.svgStrokeWidth));
            if(!object.alphaMask[(objectAlphaMaskIndex)] && 
               objectAlphaMaskIndex < object.alphaMask.length &&
               objectAlphaMaskIndex >= 0) {
                hit = true;
                return;
            }
        }
    });

    return hit;
}

WickObject.prototype.clone = function (args) {
    return wickPlayer.cloneObject(this, args);
};

WickObject.prototype.delete = function () {
    return wickPlayer.deleteObject(this);
};

WickObject.prototype.setCursor = function (cursor) {
    this.cursor = cursor;
}

WickObject.prototype.isHoveredOver = function () {
    return this.hoveredOver;
}

WickObject.prototype.prepareForPlayer = function () {
    // Set all playhead vars
    if(this.isSymbol) {
        // Set this object to it's first frame
        this.playheadPosition = 0;

        this.clones = [];

        // Start the object playing
        this._playing = true;
        this._active = false;
        this._wasActiveLastTick = false;

        this.layers.forEach(function (layer) {
            layer.hidden = false;
        })

        this.getAllFrames().forEach(function (frame) {
            //frame.prepareForPlayer();
        });
        this.getAllChildObjects().forEach(function (o) {
            o.prepareForPlayer();
        })
    }

    // Reset the mouse hovered over state flag
    this.hoveredOver = false;
}

/* Generate alpha mask for per-pixel hit detection */
WickObject.prototype.generateAlphaMask = function (imageData) {

    var that = this;

    var alphaMaskSrc = imageData || that.asset.getData();
    if(!alphaMaskSrc) return;

    //window.open(alphaMaskSrc)

    ImageToCanvas(alphaMaskSrc, function (canvas,ctx) {
        //if(window.wickPlayer) window.open(canvas.toDataURL())
        var w = canvas.width;
        var h = canvas.height;
        var rgba = ctx.getImageData(0,0,w,h).data;
        that.alphaMask = [];
        for (var y = 0; y < h; y ++) {
            for (var x = 0; x < w; x ++) {
                var alphaMaskIndex = x+y*w;
                that.alphaMask[alphaMaskIndex] = rgba[alphaMaskIndex*4+3] <= 10;
            }
        }
    }, {width:Math.floor(that.width+that.svgStrokeWidth), height:Math.floor(that.height+that.svgStrokeWidth)} );

}

WickObject.prototype.getCurrentFrames = function () {
    var currentFrames = [];

    this.layers.forEach(function (layer) {
        var frame = layer.getCurrentFrame();
        if(frame) currentFrames.push(frame)
    });

    return currentFrames;
}

WickObject.prototype.tick = function () {
    var self = this;

    if(this.isSymbol) {
        this.layers.forEach(function (layer) {
            layer.frames.forEach(function (frame) {
                frame.tick();
            });
        });
    }

    if(this.isButton) {
        this.stop();
        if(this._beingClicked) {
            if(this.getFrameByPlayheadPosition(2))
                this.movePlayheadTo(3);
        } else if (this.hoveredOver) {
            if(this.getFrameByPlayheadPosition(1))
                this.movePlayheadTo(2);
        } else {
            if(this.getFrameByPlayheadPosition(0))
                this.movePlayheadTo(1);
        }
    }

    if(this.isSymbol) {
        if(true) {
            if(this._wasClicked) {
                (wickPlayer || wickEditor).project.runScript(this, 'mousePressed');
                this._wasClicked = false;
            }

            if(this._beingClicked) {
                (wickPlayer || wickEditor).project.runScript(this, 'mouseDown');
                this._wasClicked = false;
            }

            if(this._wasClickedOff) {
                (wickPlayer || wickEditor).project.runScript(this, 'mouseReleased');
                this._wasClickedOff = false;
            }

            if(this.isHoveredOver()) {
                (wickPlayer || wickEditor).project.runScript(this, 'mouseHover');
            }

            if(this._wasHoveredOver) {
                (wickPlayer || wickEditor).project.runScript(this, 'mouseEnter');
                this._wasHoveredOver = false;
            }

            if(this._mouseJustLeft) {
                (wickPlayer || wickEditor).project.runScript(this, 'mouseLeave');
                this._mouseJustLeft = false;
            }

            wickPlayer.inputHandler.getAllKeysJustReleased().forEach(function (key) {
                (wickPlayer || wickEditor).project.runScript(self, 'keyReleased', key);
            });

            wickPlayer.inputHandler.getAllKeysJustPressed().forEach(function (key) {
                (wickPlayer || wickEditor).project.runScript(self, 'keyPressed', key);
            });

            wickPlayer.inputHandler.getAllKeysDown().forEach(function (key) {
                (wickPlayer || wickEditor).project.runScript(self, 'keyDown', key);
            });

            // Inactive -> Inactive
            if (!this._wasActiveLastTick && !this._active) {
                
            }
            // Inactive -> Active
            else if (!this._wasActiveLastTick && this._active) {
                (wickPlayer || wickEditor).project.initScript(this);

                (wickPlayer || wickEditor).project.runScript(this, 'load');
                (wickPlayer || wickEditor).project.runScript(this, 'update');

                // Force playhead update on first tick to fix:
                // https://github.com/zrispo/wick-editor/issues/810
                if(this._newPlayheadPosition) {
                    this.playheadPosition = this._newPlayheadPosition;
                    this._newPlayheadPosition = undefined;
                }
            }
            // Active -> Active
            else if (this._wasActiveLastTick && this._active) {
                (wickPlayer || wickEditor).project.runScript(this, 'update');
            }
            // Active -> Inactive
            else if (this._wasActiveLastTick && !this._active) {
                if(!this.parentFrame.alwaysSaveState) {
                    wickPlayer.resetStateOfObject(this);
                }
            }
        }

        if(this.isSymbol) {
            if(this._active) {
                this.advanceTimeline();
            }
        
            this.currentFrameNumber = this.playheadPosition+1;
            var self = this;
            this.getActiveFrames().forEach(function (frame) {
                self.currentFrameName = frame.name;
            });
        }
    }

}

WickObject.prototype.advanceTimeline = function () {
    if(this._playing && this.isSymbol && this._newPlayheadPosition === undefined) {
        this._newPlayheadPosition = this.playheadPosition+1;
        if(this._newPlayheadPosition >= this.getTotalTimelineLength()) {
            this._newPlayheadPosition = 0;
        }
    }
}

WickObject.prototype.isActive = function () {
    if(this.isRoot) return true;

    return this.parentFrame._active;
}

WickObject.prototype.setText = function (text) {
    this.textData.text = String(text); // Convert to a string, just in case.
    this._renderDirty = true;  
}

WickObject.prototype.moveUp = function ( d ) {
    this.y -= d === undefined ? 1 : d;
}

WickObject.prototype.moveDown = function ( d ) {
    this.y += d === undefined ? 1 : d;
}

WickObject.prototype.moveLeft = function ( d ) {
    this.x -= d === undefined ? 1 : d;
}

WickObject.prototype.moveRight = function ( d ) {
    this.x += d === undefined ? 1 : d;
}

WickObject.prototype.pointTo = function ( x2, y2 ) {
    var dx = this.x - x2,
        dy = this.y - y2;
    
    this.rotation = Math.atan2(dy,dx) * 180 / Math.PI - 90;
};
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickAsset = function (data, type, filename, compress) {

    this.data = data;
    this.type = type;
    this.filename = filename;
    this.compressed = compress;

    if(compress) {
        console.log("big file size: " + this.data.length);
        this.data = LZString.compressToBase64(this.data);
        console.log("compressed file size: " + this.data.length);
        console.log("Look how much space we saved wow!");
    }

}

WickAsset.prototype.getData = function () {
    if(this.compressed) {
        return LZString.decompressFromBase64(this.data);
    } else {
        return this.data;
    }
}

WickAsset.prototype.getType = function () {
    return this.type;
}

WickAsset.prototype.getFilename = function () {
    return this.filename;
}</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickProject = function () {

    // Create the root object. The editor is always editing the root
    // object or its sub-objects and cannot ever leave the root object.
    this.createNewRootObject();

    // Only used by the editor. Keeps track of current object editor is editing.
    this.currentObject = this.rootObject;
    this.rootObject.currentFrame = 0;

    this.library = new AssetLibrary();

    this.name = "New Project";

    this.onionSkinning = false;
    this.smallFramesMode = false;
    
    this.width = 720;
    this.height = 480;

    this.backgroundColor = "#FFFFFF";
    this.transparent = false;

    this.pixelPerfectRendering = false;

    this.framerate = 12;

    this.uuid = random.uuid4();

    this._selection = [];

    if(window.wickVersion) this.wickVersion = window.wickVersion;

};

WickProject.prototype.createNewRootObject = function () {
    var rootObject = new WickObject();
    rootObject.isSymbol = true;
    rootObject.isRoot = true;
    rootObject.playheadPosition = 0;
    rootObject.currentLayer = 0;
    var firstLayer = new WickLayer();
    firstLayer.identifier = "Layer 1";
    rootObject.layers = [firstLayer];
    rootObject.x = 0;
    rootObject.y = 0;
    rootObject.opacity = 1.0;
    this.rootObject = rootObject;
    this.rootObject.generateParentObjectReferences();
}

WickProject.fromFile = function (file, callback) {

    var reader = new FileReader();
    reader.onload = function(e) {
        if (file.type === "text/html") {
            callback(WickProject.fromWebpage(e.target.result));
        } else if (file.type === "application/json") {
            callback(WickProject.fromJSON(e.target.result));
        }
    };
    reader.readAsText(file);

}

WickProject.fromZIP = function (file, callback) {
      JSZip.loadAsync(file).then(function (zip) {
          return zip.file("index.html").async("text");
        }).then(function (txt) {
          callback(WickProject.fromWebpage(txt));
        });
}

WickProject.fromWebpage = function (webpageString) {

    var extractedProjectJSON;

    var webpageStringLines = webpageString.split('\n');
    webpageStringLines.forEach(function (line) {
        if(line.startsWith("<script>var wickPlayer = new WickPlayer(); wickPlayer.runProject(")) {
            extractedProjectJSON = line.split("'")[1];
        }
    });

    if(!extractedProjectJSON) {
        // Oh no, something went wrong
        console.error("Bundled JSON project not found in specified HTML file (webpageString). The HTML supplied might not be a Wick project, or zach might have changed the way projects are bundled. See WickProject.Exporter.js!");
        return null;
    } else {
        // Found a bundled project's JSON, let's load it!
        return WickProject.fromJSON(extractedProjectJSON);
    }
}

WickProject.fromJSON = function (rawJSONProject, uncompressed) {

    var JSONString = uncompressed ? rawJSONProject : WickProject.Compressor.decompressProject(rawJSONProject);

    // Replace current project with project in JSON
    var projectFromJSON = JSON.parse(JSONString);

    // Put prototypes back on object ('class methods'), they don't get JSONified on project export.
    projectFromJSON.__proto__ = WickProject.prototype;
    WickObject.addPrototypes(projectFromJSON.rootObject);

    WickProject.fixForBackwardsCompatibility(projectFromJSON);
    projectFromJSON.library.__proto__ = AssetLibrary.prototype;
    AssetLibrary.addPrototypes(projectFromJSON.library);

    // Decode scripts back to human-readble and eval()-able format
    projectFromJSON.rootObject.decodeStrings();
    projectFromJSON.library.decodeStrings();

    // Add references to wickobject's parents (optimization)
    projectFromJSON.rootObject.generateParentObjectReferences();
    projectFromJSON.regenAssetReferences();

    // Start at the first from of the root object
    projectFromJSON.currentObject = projectFromJSON.rootObject;
    projectFromJSON.rootObject.playheadPosition = 0;
    projectFromJSON.currentObject.currentLayer = 0;

    projectFromJSON.currentObject = projectFromJSON.rootObject;

    return projectFromJSON;
}

// Backwards compatibility for old Wick projects
WickProject.fixForBackwardsCompatibility = function (project) {

    var allObjectsInProject = project.rootObject.getAllChildObjectsRecursive();
    allObjectsInProject.push(project.rootObject);
    allObjectsInProject.forEach(function (wickObj) {
        // Tweens belong to frames now
        if(wickObj.tweens) wickObj.tweens = null;

        if(!wickObj.isSymbol) return
        wickObj.layers.forEach(function (layer) {
            if(!layer.locked) layer.locked = false;
            if(!layer.hidden) layer.hidden = false;
            layer.frames.forEach(function (frame) {
                if(!frame.tweens) frame.tweens = [];
                // Make sure tweens have rotations now
                frame.tweens.forEach(function (tween) {
                    if(!tween.rotations) tween.rotations = 0;
                });
            });
        });
    });

    // Selection is handled in the project now
    if(!project._selection){
        project._selection = [];
    }

    // Data for sounds and images is stored in the asset library now
    if(!project.library) {
        project.library = new AssetLibrary();

        allObjectsInProject.forEach(function (wickObject) {
            if(wickObject.imageData) {
                var asset = new WickAsset(wickObject.imageData, 'image', 'untitled');
                wickObject.assetUUID = project.library.addAsset(asset);
                wickObject.isImage = true;
                wickObject.imageData = null;
                wickObject.name = 'untitled';
            } else if(wickObject.audioData) {
                var asset = new WickAsset(wickObject.imageData, 'audio', 'untitled');
                var assetUUID = project.library.addAsset(asset);
            }
        })
    }

    project.library.__proto__ = AssetLibrary.prototype;
    project.library.regenAssetUUIDs();

}

WickProject.prototype.getAsJSON = function (callback, format) {

    var self = this;

    // Encode scripts/text to avoid JSON format problems
    self.rootObject.encodeStrings();
    self.library.encodeStrings();

    // Add some browser/OS/wick editor version info for debugging other ppl's projects
    self.metaInfo = getBrowserAndOSInfo();
    self.metaInfo.wickVersion = wickEditor.version;
    self.metaInfo.dateSaved = new Date().toGMTString();

    var JSONProject = JSON.stringify(self, WickProject.Exporter.JSONReplacer, format);
    
    // Decode scripts back to human-readble and eval()-able format
    self.rootObject.decodeStrings();
    self.library.decodeStrings();

    callback(JSONProject);

}

WickProject.prototype.getCopyData = function () {
    var objectJSONs = [];
    var objects = this.getSelectedObjects();
    objects.forEach(function(obj) {
        if(obj instanceof WickObject)
            obj._tempZIndex = wickEditor.project.getCurrentFrame().wickObjects.indexOf(obj);
    })
    objects.sort(function (a,b) {
        return a._tempZIndex - b._tempZIndex;
    });
    for(var i = 0; i < objects.length; i++) {
        objectJSONs.push(objects[i].getAsJSON());
    }
    var clipboardObject = {
        groupPosition: {x : 0,
                        y : 0},
        wickObjectArray: objectJSONs
    }
    return JSON.stringify(clipboardObject);
}

WickProject.prototype.getCurrentObject = function () {
    return this.currentObject;
}

WickProject.prototype.getCurrentLayer = function () {
    return this.getCurrentObject().getCurrentLayer();
}

WickProject.prototype.getCurrentFrame = function () {
    return this.getCurrentObject().getCurrentLayer().getCurrentFrame();
}

WickProject.prototype.getCurrentFrames = function () {
    return this.getCurrentObject().getCurrentFrames();
}

WickProject.prototype.getAllObjects = function () {
    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();
    return allObjectsInProject;
}

WickProject.prototype.getAllFrames = function () {
    var frames = [];

    var allObjectsInProject = this.getAllObjects();
    allObjectsInProject.forEach(function (obj) {
        frames = frames.concat(obj.getAllFrames());
    });

    return frames;
}

WickProject.prototype.getObjectByUUID = function (uuid) {
    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();
    allObjectsInProject.push(this.rootObject);

    var foundObj = null;
    allObjectsInProject.forEach(function (object) {
        if(foundObj) return;
        if(object.uuid === uuid) {
            foundObj = object;
        }
    });

    return foundObj;
}

WickProject.prototype.getObject = function (name) {
    return this.getObjectByName(name);
}

WickProject.prototype.getObjectByName = function (name) {
    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();
    allObjectsInProject.push(this.rootObject);

    var foundObj = null;
    allObjectsInProject.forEach(function (object) {
        if(foundObj) return;
        if(object.name === name) {
            foundObj = object;
        }
    });

    return foundObj;
}

WickProject.prototype.getFrameByUUID = function (uuid) {
    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();
    allObjectsInProject.push(this.rootObject);

    var foundFrame = null;
    allObjectsInProject.forEach(function (object) {
        if(!object.isSymbol) return;
        object.layers.forEach(function (layer) {
            layer.frames.forEach(function (frame) {
                if(frame.uuid === uuid) {
                    foundFrame = frame;
                }   
            });
        })
    });

    return foundFrame;
}

WickProject.prototype.addObject = function (wickObject, zIndex, ignoreSymbolOffset, frame) {

    var frame = frame || this.getCurrentFrame();

    if(!ignoreSymbolOffset) {
        var insideSymbolOffset = this.currentObject.getAbsolutePosition();
        wickObject.x -= insideSymbolOffset.x;
        wickObject.y -= insideSymbolOffset.y;
    }

    if(!wickObject.uuid) wickObject.uuid = random.uuid4();
    
    if(zIndex === undefined || zIndex === null) {
        frame.wickObjects.push(wickObject);
    } else {
        frame.wickObjects.splice(zIndex, 0, wickObject);
    }

    this.rootObject.generateParentObjectReferences();

}

WickProject.prototype.getNextAvailableName = function (baseName) {

    var nextName = baseName;
    var number = 0;

    this.getAllObjects().forEach(function (object) {
        if(!object.name) return;
        var nameSuffix = object.name.split(baseName)[1]

        if(nameSuffix === "") {
            if(number === 0)
                number = 1;
        } else {
            var prefixNumber = parseInt(nameSuffix);
            if(!isNaN(prefixNumber) && prefixNumber > number) 
                number = prefixNumber;
        }
    });

    if(number === 0) {
        return baseName;
    } else {
        return baseName + " " + (number+1);
    }

}

WickProject.prototype.jumpToObject = function (obj) {

    var that = this;

    this.rootObject.getAllChildObjectsRecursive().forEach(function (child) {
        if(child.uuid === obj.uuid) {
            that.currentObject = child.parentObject;
        }
    });

    var currentObject = this.currentObject;
    var frameWithChild = currentObject.getFrameWithChild(obj);
    var playheadPositionWithChild = frameWithChild.playheadPosition
    currentObject.playheadPosition = playheadPositionWithChild;

}

WickProject.prototype.jumpToFrame = function (frame) {

    var that = this;

    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();
    allObjectsInProject.push(this.rootObject);
    allObjectsInProject.forEach(function (child) {
        if(!child.isSymbol) return;
        child.layers.forEach(function (layer) {
            layer.frames.forEach(function (currframe) {
                if(frame === currframe) {
                    that.currentObject = child;
                }
            })
        })
    });

    var currentObject = this.currentObject;
    var frameWithChild = frame;
    var playheadPositionWithChild = frameWithChild.playheadPosition
    currentObject.playheadPosition = playheadPositionWithChild;
}

WickProject.prototype.hasSyntaxErrors = function () {

    var projectHasSyntaxErrors = false;

    this.rootObject.getAllChildObjectsRecursive().forEach(function (child) {
        child.getAllFrames().forEach(function (frame) {
            if(frame.scriptError && frame.scriptError.type === 'syntax') {
                projectHasSyntaxErrors = true;
            }
        });

        if(child.scriptError && child.scriptError.type === 'syntax') {
            projectHasSyntaxErrors = true;
        }
    });

    return projectHasSyntaxErrors;

}

WickProject.prototype.handleWickError = function (e, objectCausedError) {

    objectCausedError = window.errorCausingObject
    if(objectCausedError.objectClonedFrom) {
        objectCausedError = objectCausedError.objectClonedFrom
    }

    if (window.wickEditor) {
        //if(!wickEditor.builtinplayer.running) return;

        console.log("Exception thrown while running script of WickObject: " + this.name);
        console.log(e);
        var lineNumber = null;
        if(e.stack) {
            e.stack.split('\n').forEach(function (line) {
                if(lineNumber) return;
                if(!line.includes("<anonymous>:")) return;

                lineNumber = parseInt(line.split("<anonymous>:")[1].split(":")[0]);
            });
        }
        if(lineNumber) lineNumber -= 12;

        //console.log(e.stack.split("\n")[1].split('<anonymous>:')[1].split(":")[0]);
        //console.log(e.stack.split("\n"))
        //if(wickEditor.builtinplayer.running) wickEditor.builtinplayer.stopRunningProject()
        
        wickEditor.builtinplayer.stopRunningProject()

        wickEditor.scriptingide.displayError(objectCausedError, {
            message: e,
            line: lineNumber,
            type: 'runtime'
        });

        objectCausedError.scriptError = {
            message: e,
            line: lineNumber,
            type: 'runtime'
        }

    } else {
        alert("An exception was thrown while running a WickObject script. See console!");
        console.log(e);
    }
}

WickProject.prototype.isObjectSelected = function (obj) {
    var selected = false;

    this._selection.forEach(function (uuid) {
        if(obj.uuid === uuid) selected = true;
    });

    return selected;
}

WickProject.prototype.isTypeSelected = function (type) {
    var self = this;
    var selected = false;

    this._selection.forEach(function (uuid) {
        var obj = self.getObjectByUUID(uuid) 
               || self.getFrameByUUID(uuid);
        if(obj instanceof type) selected = true;
    });

    return selected;
}

WickProject.prototype.getSelectedObject = function () {
    var selectedObjects = this.getSelectedObjects();
    if(selectedObjects.length !== 1) {
        return null;
    } else {
        return selectedObjects[0];
    }
}

WickProject.prototype.getSelectedObjectByType = function (type) {
    var selectedObjects = this.getSelectedObjects();
    returnObject = null;
    
    selectedObjects.forEach(function (obj) {
        if(obj instanceof type) {
            returnObject = obj;
        }
    })

    return returnObject;
}

WickProject.prototype.getSelectedObjectsByType = function (type) {
    var selectedObjects = this.getSelectedObjects();
    
    selectedObjects = selectedObjects.filter(function (obj) {
        return (obj instanceof type);
    })

    return selectedObjects;
}

WickProject.prototype.getSelectedObjects = function () {
    var self = this;

    var objs = [];
    this._selection.forEach(function (uuid) {
        var obj = self.getObjectByUUID(uuid) 
               || self.getFrameByUUID(uuid);
               //|| self.getTweenByUUID(uuid);
        if(obj) objs.push(obj);
    });

    return objs;
}

WickProject.prototype.getSelectedWickObjects = function () {
    var self = this;

    var objs = [];
    this._selection.forEach(function (uuid) {
        var obj = self.getObjectByUUID(uuid);
        if(obj) objs.push(obj);
    });

    return objs;
}

WickProject.prototype.getSelectedObjectsUUIDs = function () {
    var self = this;

    var objs = [];
    this._selection.forEach(function (uuid) {
        var obj = self.getObjectByUUID(uuid) 
               || self.getFrameByUUID(uuid);
        if(obj) objs.push(obj.uuid);
    });

    return objs;
}

WickProject.prototype.getNumSelectedObjects = function (obj) {
    return this.getSelectedObjects().length;
}

WickProject.prototype.selectObject = function (obj) {
    wickEditor.inspector.clearSpecialMode();
    if(this._selection.indexOf(obj.uuid) === -1)
        this._selection.push(obj.uuid);
}

WickProject.prototype.selectObjectByUUID = function (uuid) {
    wickEditor.inspector.clearSpecialMode();
    if(this._selection.indexOf(uuid) === -1)
        this._selection.push(uuid);
}

WickProject.prototype.clearSelection = function () {
    var thingsWereCleared = false;
    if(this._selection.length > 0)  thingsWereCleared = true;
    this._selection = [];
    return thingsWereCleared;
}

WickProject.prototype.deselectObject = function (obj) {
    wickEditor.inspector.clearSpecialMode();
    for ( var i = 0; i < this._selection.length; i++ ) {
        var uuid = this._selection[i];
        if(obj.uuid === uuid) {
            this._selection[i] = null;
        }
    }
}

WickProject.prototype.deselectObjectType = function (type) {
    var deselectionHappened = false;
    
    for ( var i = 0; i < this._selection.length; i++ ) {
        var uuid = this._selection[i];
        var obj = this.getObjectByUUID(uuid) 
               || this.getFrameByUUID(uuid);
        if(obj instanceof type) {
            this._selection[i] = null;
            deselectionHappened = true;
        }
    }

    this._selection = this._selection.filter(function (obj) {
        return obj !== null;
    });

    return deselectionHappened;
}

WickProject.prototype.loadBuiltinFunctions = function (contextObject) {

    if(contextObject.wickScript === '') return;

    var objectScope = null;
    if(contextObject instanceof WickObject) {
        objectScope = contextObject.parentObject;
    } else if (contextObject instanceof WickFrame) {
        objectScope = contextObject.parentLayer.parentWickObject;
    }

    window.project = wickPlayer.project || wickEditor.project;
    window.parentObject = contextObject.parentObject;
    window.root = project.rootObject;

    window.play           = function ()      { objectScope.play(); }
    window.stop           = function ()      { objectScope.stop(); }
    window.movePlayheadTo = function (frame) { objectScope.movePlayheadTo(frame); }
    window.gotoAndStop    = function (frame) { objectScope.gotoAndStop(frame); }
    window.gotoAndPlay    = function (frame) { objectScope.gotoAndPlay(frame); }
    window.gotoNextFrame  = function ()      { objectScope.gotoNextFrame(); }
    window.gotoPrevFrame  = function ()      { objectScope.gotoPrevFrame(); }

    window.keyIsDown      = function (keyString) { return wickPlayer.inputHandler.keyIsDown(keyString); };
    window.keyJustPressed = function (keyString) { return wickPlayer.inputHandler.keyJustPressed(keyString); }
    window.mouseX = wickPlayer.inputHandler.getMouse().x;
    window.mouseY = wickPlayer.inputHandler.getMouse().y;
    window.mouseMoveX = wickPlayer.inputHandler.getMouseDiff().x;
    window.mouseMoveY = wickPlayer.inputHandler.getMouseDiff().y;
    window.hideCursor = function () { wickPlayer.inputHandler.hideCursor(); };
    window.showCursor = function () { wickPlayer.inputHandler.showCursor(); };

    // WickObjects in same frame (scope) are accessable without using root./parent.
    if(objectScope) {
        objectScope.getAllChildObjects().forEach(function(child) {
            if(child.name) window[child.name] = child;
        });
    }
    if(objectScope) {
        objectScope.getAllActiveChildObjects().forEach(function(child) {
            if(child.name) window[child.name] = child;
        });
    }

}

var WickObjectBuiltins = [
    'load',
    'update',
    'mousePressed',
    'mouseDown',
    'mouseReleased',
    'mouseHover',
    'mouseEnter',
    "mouseLeave",
    "keyPressed",
    "keyDown",
    "keyReleased",
];

WickProject.prototype.loadScriptOfObject = function (obj) {

    if(obj.wickScript === '') return;

    if(!window.cachedWickScripts) window.cachedWickScripts = {};

    var dummyInitScript = "";
    var dummyLoaderScript = "";
    WickObjectBuiltins.forEach(function (builtinName) {
        dummyInitScript += 'function ' + builtinName + ' (){return;};\n';
        dummyLoaderScript += '\nthis.'+builtinName+"="+builtinName+";";
    });

    var evalScriptTag = '<script>\nwindow.cachedWickScripts["'+obj.uuid+'"] = function () {\n' + dummyInitScript + obj.wickScript + dummyLoaderScript + '\n}\n<'+'/'+'script>';
    $('head').append(evalScriptTag);
}

WickProject.prototype.initScript = function (obj) {
    window.errorCausingObject = obj;

    if(!window.cachedWickScripts) window.cachedWickScripts = {};
    
    if(!obj.cachedWickScript) {
        if(obj.sourceUUID) {
            obj.cachedWickScript = window.cachedWickScripts[obj.sourceUUID];
        } else {
            obj.cachedWickScript = window.cachedWickScripts[obj.uuid];
        }
    }

    if(obj.cachedWickScript) {
        this.loadBuiltinFunctions(obj);
        try {
            obj.cachedWickScript();
        } catch (e) {
            this.handleWickError(e,obj);
        }
    }
}

WickProject.prototype.runScript = function (obj, fnName, arg1, arg2, arg3) {

    window.errorCausingObject = obj;

    try {
        if(obj[fnName]) {
            this.loadBuiltinFunctions(obj);
            obj[fnName](arg1, arg2, arg3);
        }
    } catch (e) {
        this.handleWickError(e,obj);
    }

}

WickProject.prototype.regenAssetReferences = function () {

    var self = this;

    self.getAllObjects().forEach(function (obj) {
        obj.asset = self.library.getAsset(obj.assetUUID);
    });

}

WickProject.prototype.loadFonts = function (callback) {
    var self = this;
    var fontsInProject = [];
    self.getAllObjects().forEach(function (o) {
        if(o.isText && o.textData.fontFamily !== 'Arial' && o.textData.fontFamily !== 'arial' && fontsInProject.indexOf(o.textData.fontFamily))
            fontsInProject.push(o.textData.fontFamily);
    });
    if(fontsInProject.length === 0 && callback) {
        callback()
    } else {
        loadGoogleFonts(fontsInProject, function () {
            if(window.wickEditor) {
                wickEditor.canvas.getInteractiveCanvas().needsUpdate = true;
                wickEditor.syncInterfaces();
            }
            if(callback) {
                callback();
            }
        });
    }   
}

WickProject.prototype.prepareForPlayer = function () {
    var self = this;

    self.regenAssetReferences();

    self.rootObject.prepareForPlayer();
    if(window.WickEditor) self.loadFonts();

    self.getAllObjects().forEach(function (obj) {
        self.loadScriptOfObject(obj);
    });
    self.getAllFrames().forEach(function (obj) {
        self.loadScriptOfObject(obj);
    });
}

WickProject.prototype.tick = function () {
    var allObjectsInProject = this.rootObject.getAllChildObjectsRecursive();

    // Make sure all playhead positions are up to date 
    // (this is deferred to outside the main tick code so timeline changes happen all at once right here)
    allObjectsInProject.forEach(function (obj) {
        if(obj._newPlayheadPosition !== undefined)
            obj.playheadPosition = obj._newPlayheadPosition;
    });

    allObjectsInProject.forEach(function (obj) {
        obj._newPlayheadPosition = undefined;
    });
    allObjectsInProject.forEach(function (obj) {
        obj.getAllFrames().forEach(function (frame) {
            frame._wasActiveLastTick = frame._active;
            frame._active = frame.isActive();
        });
    });
    allObjectsInProject.forEach(function (obj) {
        obj._wasActiveLastTick = obj._active;
        obj._active = obj.isActive();
    });
    
    this.rootObject.tick();
    this.updateCamera();
    this.applyTweens();
}

WickProject.prototype.applyTweens = function () {
    this.getAllFrames().forEach(function (frame) {
        frame.applyTween();
    });
}

WickProject.prototype.updateCamera = function () {
    var camera = window.camera;
    if(!camera) return;

    camera.update();

    var camPos = camera.getPosition();
    this.rootObject.x = -camPos.x+this.width/2;
    this.rootObject.y = -camPos.y+this.height/2;
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickCamera = function (project) {

    var self = this;

    var x = project.width/2;
    var y = project.height/2;

    var followingObject = null;
    var followingSmoothness = 1;

    this.followObject = function (object, smoothness) {
    	followingObject = object;
    	followingSmoothness = smoothness || 1;
    }

    this.getPosition = function () {
    	return {
    		x: x, 
    		y: y
    	};
    }

    this.setPosition = function (_x,_y) {
    	x = _x;
    	y = _y;
    }

    this.update = function () {
    	if(followingObject) {
    		var dx = followingObject.x - x;
    		var dy = followingObject.y - y;
    		self.setPosition(
    			x + dx*followingSmoothness, 
    			y + dy*followingSmoothness
    		);
    	}
    }

};

</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */
    
var AssetLibrary = function () {

    this.assets = {};

};

AssetLibrary.prototype.addAsset = function (asset) {

    if(asset.uuid) {
        this.assets[asset.uuid] = asset;
    } else {
        var uuid = random.uuid4();
        this.assets[uuid] = asset;
        asset.uuid = uuid;

        return uuid;
    }

    wickEditor.library.dirty = true;

}

AssetLibrary.prototype.deleteAsset = function (uuid) {

    this.assets[uuid] = null;
    delete this.assets[uuid];
    
    wickEditor.library.dirty = true;

}

AssetLibrary.prototype.getAsset = function (uuid) {

    return this.assets[uuid];

}

AssetLibrary.prototype.getAllAssets = function (type) {

    var allAssets = [];

    for (assetUUID in this.assets) {
        var asset = this.assets[assetUUID];
        if(!type || asset.type === type) {
            allAssets.push(asset);
        }
    }

    return allAssets;

}

AssetLibrary.prototype.getAssetByName = function (filename) {

    var foundAsset = null;
    this.getAllAssets().forEach(function (asset) {
        if (asset.filename === filename)
            foundAsset = asset;
    });
    return foundAsset

}

/* For backwards compatibility... */
AssetLibrary.prototype.regenAssetUUIDs = function () {

    for (assetUUID in this.assets) {
        var asset = this.assets[assetUUID];
        asset.uuid = assetUUID;
    }

}

AssetLibrary.prototype.printInfo = function () {

    var totalSize = 0;
    for (assetUUID in this.assets) {
        var asset = this.assets[assetUUID];
        totalSize += asset.data.length;

        console.log("Filename: "+asset.filename);
        console.log("Type: "+asset.type);
        console.log("Size: "+asset.data.length);
        console.log("---")
    }
    console.log("Total library size: " + totalSize)

}

AssetLibrary.prototype.encodeStrings = function () {
    this.getAllAssets().forEach(function (asset) {
        asset.filename = WickProject.Compressor.encodeString(asset.filename);
    });
}

AssetLibrary.prototype.decodeStrings = function () {
    this.getAllAssets().forEach(function (asset) {
        asset.filename = WickProject.Compressor.decodeString(asset.filename);
    });
}

AssetLibrary.addPrototypes = function (library) {

    for (assetUUID in library.assets) {
        library.assets[assetUUID].__proto__ = WickAsset.prototype;
    }

}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

WickProject.Compressor = (function () {

    var projectCompressor = { };

    var printFilesize = false;

    var compressionRoutines = {
        'LZSTRING-BASE64': {
            compress:LZString.compressToBase64, 
            decompress:LZString.decompressFromBase64
        },
        'LZSTRING-UTF16': {
            compress:LZString.compressToUTF16, 
            decompress:LZString.decompressFromUTF16
        }
    }

    projectCompressor.compressProject = function (projectJSON, compressionRoutineName) {
        if(printFilesize) console.log("Compressing project of size " + projectJSON.length);

        var compressionRoutine = compressionRoutines[compressionRoutineName];
        var compressedProjectJSON = compressionRoutineName+compressionRoutine.compress(projectJSON)

        if(printFilesize) console.log("Done! Result size " + compressedProjectJSON.length);
        return compressedProjectJSON;
    }

    projectCompressor.decompressProject = function (compressedProjectJSON) {
        if(printFilesize) console.log("Decompressing project...")

        var projectJSON = compressedProjectJSON;

        for (var compressionRoutineName in compressionRoutines) {
            if(compressedProjectJSON.startsWith(compressionRoutineName)) {
                console.log("Project compressed with " + compressionRoutineName)
                var compressionRoutine = compressionRoutines[compressionRoutineName];
                var rawCompressedProjectJSON = compressedProjectJSON.substring(compressionRoutineName.length, compressedProjectJSON.length);
                projectJSON = compressionRoutine.decompress(rawCompressedProjectJSON);
            }
        }

        if(printFilesize) console.log("Done!");
        return projectJSON;
    }
    
    projectCompressor.encodeString = function (str) {
        var newStr = str;
        newStr = encodeURI(str);
        newStr = newStr.replace(/'/g, "%27");
        return newStr;
    }

    projectCompressor.decodeString = function (str) {
        var newStr = str;
        newStr = newStr.replace(/%27/g, "'");
        newStr = decodeURI(str);
        return newStr;
    }

    return projectCompressor;

})();</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickPixiRenderer = function (canvasContainer) {

    var self = this;

    var SVG_SCALE = 1.4;

    var renderer = PIXI.autoDetectRenderer(100, 100, {
        backgroundColor : "#FFFFFF", 
        resolution: window.devicePixelRatio,
        preserveDrawingBuffer: true,
        antialias: true,
        transparent: true,
    });
    renderer.clearBeforeRender = true;
    renderer.roundPixels = false;
    renderer.view.setAttribute('tabindex', 0);

    canvasContainer.appendChild(renderer.view);
    renderer.view.focus();

    var currentProjectUUID = null;
    var container = new PIXI.Container();
    var pixiSprites = {};
    var pixiTextures = {};

    var wickProject;

    var graphics = new PIXI.Graphics();
    
    container.addChild(graphics);

    _cached_w = 0;
    _cached_h = 0;

    self.preloadAllAssets = function (project, callback) {
        currentProjectUUID = project.uuid;

        wickProject = project;

        var assetsToLoad = [];
        project.getAllObjects().forEach(function (o) {
            if((o.isPath && o.pathData) || o.isImage || o.isText) {
                assetsToLoad.push(o);
            }
        });

        var loadedAssetCount = 0;
        assetsToLoad.forEach(function (o) {
            function checkIfDone () {
                if(loadedAssetCount === assetsToLoad.length) {
                    callback();
                }
            }

            if (!pixiSprites[o.uuid]) {
                createPixiSprite(o, function () {
                    loadedAssetCount++;
                    checkIfDone()
                });
            } else if(o._renderDirty) {
                regenPixiPath(o, pixiSprites[o.uuid], function () {
                    loadedAssetCount++;
                    checkIfDone()
                });
                o._renderDirty = false;
            } else if(pixiTextures[o.uuid]) {
                loadedAssetCount++;
                checkIfDone()
            } else {
                loadedAssetCount++;
                checkIfDone();
            }
        });
    }

    self.renderWickObjects = function (project, wickObjects, renderExtraSpace, fitToScreen) {
        window._lastRender = {
            project: project,
            wickObjects: wickObjects, 
            renderExtraSpace: renderExtraSpace
        }
        if(!renderExtraSpace) renderExtraSpace = 1;

        if(renderExtraSpace === 1) {
            graphics.clear();
            graphics.beginFill(parseInt(project.backgroundColor.replace("#","0x")));
            graphics.moveTo(0, 0);
            graphics.lineTo(project.width, 0);
            graphics.lineTo(project.width, project.height);
            graphics.lineTo(0, project.height);
            graphics.endFill();
        }

        wickProject = project;

        if(currentProjectUUID !== project.uuid) {
            currentProjectUUID = project.uuid;
            loadAllAssets(project);
        }

        if(fitToScreen) {
            var w = project.width;
            var h = project.height;
            canvasContainer.style.width  = w + 'px';
            canvasContainer.style.height = h + 'px';
            if(_cached_w !== w || _cached_h !== h) {
                renderer.resize(w, h);
                _cached_w = w;
                _cached_h = h;
                renderer.view.style.width  = w + "px";
                renderer.view.style.height = h + "px";
                container.scale.x = 1//w / project.width;
                container.scale.y = 1//h / project.height;
            }
        } else {
            container.position.x = 0;
            container.position.y = 0;
            renderer.resize(project.width*renderExtraSpace, project.height*renderExtraSpace);
            renderer.view.style.width  = project.width*renderExtraSpace  + "px";
            renderer.view.style.height = project.height*renderExtraSpace + "px";
            if(renderer.width !== project.width || renderer.height !== project.height) {
                renderer.resize(project.width*renderExtraSpace, project.height*renderExtraSpace);
                renderer.view.style.width  = project.width*renderExtraSpace  + "px";
                renderer.view.style.height = project.height*renderExtraSpace + "px";

                if(renderExtraSpace !== 1) {
                    container.position.x = project.width/renderExtraSpace;
                    container.position.y = project.height/renderExtraSpace;
                }
            }
        }

        for (uuid in pixiSprites) {
            pixiSprites[uuid].visible = false;
        }

        wickObjects.forEach(function (wickObject) {
            renderWickObject(wickObject);
        });
        renderer.render(container);
    }

    self.reorderAllObjects = function (project) {
        var objectsToReorder = container.removeChildren(0, container.children.length);
        var allWickObjects = project.getAllObjects();

        container.addChild(graphics);
        allWickObjects.forEach(function (wickObject) {
            objectsToReorder.forEach(function (pixiObject) {
                if(pixiSprites[wickObject.uuid] === pixiObject) {
                    container.addChild(pixiObject);
                }
            });
        });
    }

    self.cleanupObjectTextures = function (wickObj) {
        var sprite = pixiSprites[wickObj.uuid];
        if(sprite)
            sprite.parent.removeChild(sprite);
    }

    function renderWickObject (wickObject) {
        var sprite = pixiSprites[wickObject.uuid];
        if(!sprite && !wickObject.isSymbol) {
            createPixiSprite(wickObject);
        }
        if(sprite && wickObject._renderDirty && wickObject.isPath) {
            regenPixiPath(wickObject, sprite);
            wickObject._renderDirty = false;
        }
        if(sprite && wickObject._renderDirty && wickObject.isText) {
            sprite = regenPixiText(wickObject, sprite);
            wickObject._renderDirty = false;
        }
        if(sprite) {
            sprite.visible = !wickObject.parentFrame.parentLayer.hidden;
            sprite.anchor = new PIXI.Point(0.5, 0.5);
            var textureScale = (wickObject.pathData || wickObject.isText ? SVG_SCALE : 1);

            var absTransforms = wickObject.getAbsoluteTransformations();
            var textOffset = wickObject.isText ? 
                rotate_point(sprite.textboxOffset, 0, 0, 0, absTransforms.rotation) :
                {x:0,y:0};
            sprite.position.x = absTransforms.position.x - textOffset.x;
            sprite.position.y = absTransforms.position.y - textOffset.y;
            sprite.rotation = absTransforms.rotation/360*2*3.14159;
            sprite.scale.x = absTransforms.scale.x/textureScale;
            sprite.scale.y = absTransforms.scale.y/textureScale;
            sprite.alpha = absTransforms.opacity;
            sprite.scale.x *= (absTransforms.flip.x ? -1 : 1);
            sprite.scale.y *= (absTransforms.flip.y ? -1 : 1);
        }

        wickObject.getAllActiveChildObjects().forEach(function (child) {
            renderWickObject(child);
        });
    }

    function loadAllAssets (project) {
        project.getAllObjects().forEach(function (wickObject) {
            createPixiSprite(wickObject);
        });
    }

    function createPixiSprite (wickObject, callback) {
        if(wickObject.sourceUUID) {
            var pixiTexture = pixiTextures[wickObject.sourceUUID];
            if(pixiTexture) {
                var pixiSprite = new PIXI.Sprite(pixiTexture);
                wickObject.alphaMask = wickProject.getObjectByUUID(wickObject.sourceUUID).alphaMask
                var sourceIndex = container.children.indexOf(pixiSprites[wickObject.sourceUUID])
                container.addChildAt(pixiSprite, sourceIndex);
                pixiSprites[wickObject.uuid] = pixiSprite;
                pixiSprite.visible = false;
                return;
            }
        }

        var type;

        if (wickObject.asset && wickObject.asset.type === 'image') {
            type = 'image';
        } else if (wickObject.isPath && wickObject.pathData) {
            type = 'svg';
        } else if (wickObject.isText) {
            type = 'text';
        }

        if(type) {
            var newPixiSprite = WickToPixiSprite[type](wickObject, callback);
            container.addChild(newPixiSprite);
            pixiSprites[wickObject.uuid] = newPixiSprite;

            var textureSrc = newPixiSprite.texture.baseTexture.imageUrl;
            if(textureSrc && !wickProject.disableAlphaMaskGeneration)
                wickObject.generateAlphaMask(textureSrc);
        }
    }

    function regenPixiPath (wickObject, pixiSprite, callback) {
        var base64svg = getBase64SVG(wickObject);
        var texture = PIXI.Texture.fromImage(base64svg, undefined, undefined, SVG_SCALE);
        pixiSprite.setTexture(texture);
        texture.baseTexture.on('loaded', function(){
            if(callback) callback();
        });
    }

    function regenPixiText (wickObject, pixiSprite) {
        container.removeChild(pixiSprite);
        var newPixiText = WickToPixiSprite['text'](wickObject);
        container.addChild(newPixiText);
        pixiSprites[wickObject.uuid] = newPixiText;
        return newPixiText;
    }

    var WickToPixiSprite = {
        'image': function (wickObject, callback) {
            var pixiTexture = PIXI.Texture.fromImage(wickObject.asset.getData());
            var pixiSprite = new PIXI.Sprite(pixiTexture);
            pixiSprite.texture.baseTexture.on('loaded', function(){
                if(window._lastRender) {
                    self.renderWickObjects(
                        window._lastRender.project, 
                        window._lastRender.wickObjects, 
                        window._lastRender.renderExtraSpace);
                }
                if(callback) callback();
            });
            pixiTextures[wickObject.uuid] = pixiTexture;
            return pixiSprite;
        },
        'svg': function (wickObject, callback) {
            var base64svg = getBase64SVG(wickObject);
            var pixiTexture = PIXI.Texture.fromImage(base64svg, undefined, undefined, SVG_SCALE);
            var newSprite = new PIXI.Sprite(pixiTexture);
            newSprite.texture.baseTexture.on('loaded', function(){
                if(window._lastRender) {
                    self.renderWickObjects(
                        window._lastRender.project, 
                        window._lastRender.wickObjects, 
                        window._lastRender.renderExtraSpace);
                }
                if(callback) callback();
            });
            pixiTextures[wickObject.uuid] = pixiTexture;
            return newSprite;
        },
        'text': function (wickObject, callback) {
            var textData = wickObject.textData;
            var style = {
                font : textData.fontWeight + " " + textData.fontStyle + " " + (textData.fontSize*SVG_SCALE) + "px " + textData.fontFamily,
                fill : textData.fill,
                wordWrap : false,
                wordWrapWidth : wickObject.width*SVG_SCALE,
                align: textData.textAlign,
            };
            var pixiText = new PIXI.Text(textData.text, style);
            var textWidth = pixiText.width/SVG_SCALE;
            var textboxWidth = wickObject.width;
            if(textData.textAlign === 'left') {
                pixiText.textboxOffset = (textboxWidth-textWidth)/2;
            } else if (textData.textAlign === 'center') {
                pixiText.textboxOffset = 0;
            } else if (textData.textAlign === 'right') {
                pixiText.textboxOffset = -(textboxWidth-textWidth)/2;
            }
            if(callback) callback();
            return pixiText;
        }
    }

    function getBase64SVG (wickObject) {
        var parser = new DOMParser();
        var x = (wickObject.svgX || 0);
        var y = (wickObject.svgY || 0);
        if(!wickObject.svgStrokeWidth) wickObject.svgStrokeWidth = 0;
        x -= wickObject.svgStrokeWidth/2;
        y -= wickObject.svgStrokeWidth/2;
        var w = (wickObject.width  + wickObject.svgStrokeWidth*1);
        var h = (wickObject.height + wickObject.svgStrokeWidth*1);
        var svgDoc = parser.parseFromString('<svg id="svg" viewBox="'+x+' '+y+' '+w+' '+h+'" version="1.1" width="'+w+'" height="'+h+'" xmlns="http://www.w3.org/2000/svg">'+wickObject.pathData+'</svg>', "image/svg+xml");
        var s = new XMLSerializer().serializeToString(svgDoc);
        var base64svg = 'data:image/svg+xml;base64,' + window.btoa(s);
        return base64svg;
    }

};

</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */

var WickHowlerAudioPlayer = function () {

    var self = this;

    var howlSoundInstances = {};
    var frameSoundsMappings = {};
    var frameWaveforms = {};
    var framesActiveSoundID = {};

    var muted = false;

    var projectFramerateForSeekAmt;

    self.reloadSoundsInProject = function (project) {
        projectFramerateForSeekAmt = project.framerate;

        initHowlerInstancesForAllAssets(project);
        initSoundsOnFrames(project);
    }

    self.playSoundFromLibrary = function (asset) {
        if(!muted) {
            var howlerSound = howlSoundInstances[asset.uuid];
            var howlerID = howlerSound.play();
        }
    }

    self.playSoundOnFrame = function (frame) {
        if(!muted) {
            if(framesActiveSoundID[frame.uuid]) {
                framesActiveSoundID[frame.uuid] = null;
                self.stopSoundOnFrame(frame);
            }

            var howlerSound = frameSoundsMappings[frame.uuid];
            var howlerID = howlerSound.play();

            var seekAmtFrames = frame.parentObject.playheadPosition - frame.playheadPosition;
            var seekAmtSeconds = seekAmtFrames / projectFramerateForSeekAmt;
            howlerSound.volume(frame.volume);
            howlerSound.seek(seekAmtSeconds, howlerID);
            framesActiveSoundID[frame.uuid] = howlerID;
        }
    }

    self.stopSoundOnFrame = function (frame) {
        if(!muted) {
            var howlerSound = frameSoundsMappings[frame.uuid];
            var howlerID = framesActiveSoundID[frame.uuid];
            howlerSound.stop(howlerID);
            framesActiveSoundID[frame.uuid] = null;
        }
    }

    this.stopAllSounds = function () {
        for(uuid in howlSoundInstances) {
            howlSoundInstances[uuid].stop();
        }
        for(uuid in frameSoundsMappings) {
            frameSoundsMappings[uuid].stop();
        }
    }

    this.cleanup = function () {
        // todo
    }

    this.clearCacheForFrame = function (frame) {
        frameSoundsMappings[frame.uuid] = null;
        frameWaveforms[frame.uuid] = null;
    }

    this.getWaveformOfFrame = function (frame) {
        if(frameWaveforms[frame.uuid]) {
            return {
                src: frameWaveforms[frame.uuid],
                length: frameSoundsMappings[frame.uuid].duration()
            }
        }
    }

    this.getDurationOfSound = function (assetUUID) {
        return howlSoundInstances[assetUUID].duration();
    }

    this.generateAudioTrack = function (frames) {
        var frame = frames[0];
        var howlerSound = frameSoundsMappings[frame.uuid];

        console.log(howlerSound)

        var data = atob(howlerSound._src.split(',')[1]);
        var dataView = new Uint8Array(data.length);
        for (var i=0; i<data.length; ++i) {
            dataView[i] = data.charCodeAt(i);
        }

        Howler.ctx.decodeAudioData(dataView.buffer, function(buffer) {
            console.log(buffer)
        })
    }

    /* Wick player API functions */

    window.playSound = function (assetFilename) {
        var asset = (wickPlayer || wickEditor).project.library.getAssetByName(assetFilename);
        if(asset) {
            self.playSoundFromLibrary(asset);
        }
    }

    window.stopAllSounds = function () {
        self.stopAllSounds();
    }

    window.mute = function () {
        self.stopAllSounds();
        muted = true;
    }

    window.unmute = function () {
        muted = false;
    }

    /* Util */

    function initHowlerInstancesForAllAssets (project) {

        project.library.getAllAssets('audio').forEach(function (asset) {
            if(howlSoundInstances[asset.uuid]) return;

            var audioData = asset.getData();

            howlSoundInstances[asset.uuid] = new Howl({
                src: [audioData],
                loop: false,
                volume: 1.0
            });
        });

    }

    function initSoundsOnFrames (project) {

        project.getAllFrames().filter(function (frame) {
            return frame.hasSound() && !frameSoundsMappings[frame.uuid];
        }).forEach(function (frame) {
            var howlerSound = howlSoundInstances[frame.audioAssetUUID];
            frameSoundsMappings[frame.uuid] = howlerSound;
            framesActiveSoundID[frame.uuid] = null;

            if(window.WickEditor) {
                generateWaveformForFrame(frame);
            }
        });

    }

    function generateWaveformForFrame (frame) {

        var asset = window.wickEditor.project.library.getAsset(frame.audioAssetUUID);
        var src = asset.getData();
        var scwf = new SCWF();
        scwf.generate(src, {
            onComplete: function(png, pixels) {
                frameWaveforms[frame.uuid] = png;
                window.wickEditor.syncInterfaces();
            }
        });
        
    }
}
</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */
    
WickPlayerInputHandler = function (canvasContainer, wickProject) {

    var self = this;

    var mouse;
    var mouseDiff;
    var lastMouse;
    var newMouse;
    var keys;
    var keysJustPressed; 
    var keysJustReleased;

    var _cachedKeysDown;
    var _cachedKeysJustPressed;
    var _cachedKeysJustReleased;

    var project;

    var canvas = canvasContainer.children[0];

    self.setup = function () {
        mouse = null;
        keys = [];
        keysJustPressed = [];
        keysJustReleased = [];

        if(bowser.mobile || bowser.tablet) {
            // Touch event (one touch = like a mouse click)
            document.body.addEventListener("touchstart", onTouchStart, false);
            document.body.addEventListener("touchmove", onTouchMove, false);

            // Squash gesture events
            document.body.addEventListener('gesturestart',  function(e) { e.preventDefault(); });
            document.body.addEventListener('gesturechange', function(e) { e.preventDefault(); });
            document.body.addEventListener('gestureend',    function(e) { e.preventDefault(); });
        } else {
            document.body.addEventListener('mousemove', onMouseMove, false);
            document.body.addEventListener("mousedown", onMouseDown, false);
            document.body.addEventListener("mouseup",   onMouseUp,   false);

            document.body.addEventListener("keydown", onKeyDown);
            document.body.addEventListener("keyup", onKeyUp);
        }
    }

    self.update = function () {
        keysJustPressed = [];
        keysJustReleased = [];

        _cachedKeysDown = null;
        _cachedKeysJustPressed = null;
        _cachedKeysJustReleased = null;

        lastMouse = mouse;
        if(newMouse) mouse = newMouse;

        if(mouse && lastMouse) {
            mouseDiff = {
                x: mouse.x - lastMouse.x,
                y: mouse.y - lastMouse.y
            }
        }
        if(mouse && lastMouse) {
            lastMouse.x = mouse.x;
            lastMouse.y = mouse.y;
        }
    }

    self.cleanup = function () {
        document.body.removeEventListener("mousedown", onMouseDown);
        document.body.removeEventListener("mousemove", onMouseMove);
        document.body.removeEventListener("mouseup", onMouseUp);

        document.body.removeEventListener("touchstart", onTouchStart);
        document.body.removeEventListener("touchmove", onTouchMove);

        document.body.removeEventListener("keydown", onKeyDown);
        document.body.removeEventListener("keyup", onKeyUp);
    }
    
    self.getMouse = function () {
        return mouse || {x:0,y:0};
    }

    self.getMouseDiff = function () {
        return mouseDiff || {x:0,y:0};
    }

    self.getKeys = function () {
        return keys || [];
    }

    self.getKeysJustPressed = function () {
        return keysJustPressed || [];
    }

    self.getKeysJustReleased = function () {
        return keysJustReleased || [];
    }

    self.keyIsDown = function (keyString) {
        return self.getKeys()[keyCharToCode[keyString.toUpperCase()]];
    }

    self.keyJustPressed = function (keyString) {
        return self.getKeysJustPressed()[keyCharToCode[keyString.toUpperCase()]];
    }

    self.getAllKeysDown = function () {
        if(_cachedKeysDown) return _cachedKeysDown;

        _cachedKeysDown = [];

        var _keys = self.getKeys();
        for(var i = 0; i < _keys.length; i++) {
            if(_keys[i]) {
                var c = codeToKeyChar[i];
                _cachedKeysDown.push(c);
            }
        }

        return _cachedKeysDown;
    }

    self.getAllKeysJustPressed = function () {
        if(_cachedKeysJustPressed) return _cachedKeysJustPressed;

        _cachedKeysJustPressed = [];

        var _keys = self.getKeysJustPressed();
        for(var i = 0; i < _keys.length; i++) {
            if(_keys[i]) {
                var c = codeToKeyChar[i];
                _cachedKeysJustPressed.push(c);
            }
        }

        return _cachedKeysJustPressed;
    }

    self.getAllKeysJustReleased = function () {
        if(_cachedKeysJustReleased) return _cachedKeysJustReleased;

        _cachedKeysJustReleased = [];

        var _keys = self.getKeysJustReleased();
        for(var i = 0; i < _keys.length; i++) {
            if(_keys[i]) {
                var c = codeToKeyChar[i];
                _cachedKeysJustReleased.push(c);
            }
        }

        return _cachedKeysJustReleased;
    }

    self.hideCursor = function () {
        canvasContainer.className = 'hideCursor'
    }

    self.showCursor = function () {
        canvasContainer.className = ''
    }


    var onMouseMove = function (evt) {

        setMousePos(calcMousePos(canvasContainer, evt));

        canvasContainer.style.cursor = "default";

        // Check if we're hovered over a clickable object...
        var hoveredOverObj = null;
        wickProject.rootObject.getAllActiveChildObjectsRecursive(true).forEachBackwards(function(child) {
            if(!child.isSymbol) return;

            if(!(hoveredOverObj && hoveredOverObj.isButton) && child.isPointInside(self.getMouse())) {
                if(!child.hoveredOver) {
                    child._wasHoveredOver = true;
                }
                if(child.isButton) canvasContainer.style.cursor = child.cursor || "pointer";
                child.hoveredOver = true;
                hoveredOverObj = child;
            } else {
                if(child.hoveredOver) {
                    child._mouseJustLeft = true;
                }
                child.hoveredOver = false;
            }
        });

    }

    var onMouseDown = function (evt) {

        canvasContainer.focus();

        // Hack to avoid "'requestFullscreen' can only be initiated by a user gesture." error
        if(wickPlayer.fullscreenRequested) {
            wickPlayer.enterFullscreen();
            wickPlayer.fullscreenRequested = false;
        }

        var currFrame = wickProject.getCurrentFrame();
        if(currFrame) {
            currFrame._wasClicked = true;
            currFrame._beingClicked = true;
        }
        
        var clickedObj;
        wickProject.rootObject.getAllActiveChildObjectsRecursive(true).forEachBackwards(function(child) {
            if(!(clickedObj && clickedObj.isButton) && child.isPointInside(self.getMouse())) {
                child._wasClicked = true;
                child._beingClicked = true;
                clickedObj = child;
            }
        });

    }

    var onMouseUp = function (evt) {
        var currFrame = wickProject.getCurrentFrame();
        if(currFrame) {
            currFrame._beingClicked = false;
            currFrame._wasClickedOff = true;
        }

        wickProject.rootObject.getAllActiveChildObjectsRecursive(true).forEachBackwards(function(child) {
            child._beingClicked = false;

            if(child.isPointInside(self.getMouse())) {
                child._wasClickedOff = true;
            }
        });
    }

    var onKeyDown = function (event) {
        event.preventDefault();

        // Quit builtin editor
        if(window.wickEditor && event.keyCode === 27) {
            window.wickEditor.guiActionHandler.doAction('stopRunningProject')
        }

        // Check for new keyDown...
        if (!keys[event.keyCode]) {
            keysJustPressed[event.keyCode] = true; 
        }

        keys[event.keyCode] = true;
    }

    var onKeyUp = function (event) {
        event.preventDefault();

        keysJustReleased[event.keyCode] = true;
        
        keys[event.keyCode] = false;
    }

    var onTouchStart = function (evt) {

        document.getElementById('rendererCanvas').focus();

        evt.preventDefault();

        // on iOS, WebAudio context only gets 'unmuted' after first user interaction
        if(!audioContext) {
            wickPlayer.audioPlayer.setup(wickProject);
        }

        var touchPos = getTouchPos(canvasContainer, evt);
        setMousePos(touchPos);

        wickProject.rootObject.getAllActiveChildObjects().forEach(function(child) {
            if(child.isPointInside(touchPos)) {
                child._wasClicked = true;
            }
        });
        

    }

    var onTouchMove = function (evt) {

        evt.preventDefault();
        
        var touchPos = getTouchPos(canvasContainer, evt);
        setMousePos(touchPos);

    }

    var calcMousePos = function (canvas, evt) {
        var canvasBoundingClientRect = canvas.getBoundingClientRect();

        var mouseX = evt.clientX;
        var mouseY = evt.clientY;

        return {
            x: mouseX,
            y: mouseY
        };
    }

    var getTouchPos = function (canvas, evt) {
        var canvasBoundingClientRect = canvas.getBoundingClientRect();

        var touch = evt.targetTouches[0];

        var touchX = touch.pageX;
        var touchY = touch.pageY;

        return {
            x: touchX,
            y: touchY
        };
    }

    var setMousePos = function (newPos) {
        var windowScale = getWindowScale();
        newMouse = {
            x: newPos.x * windowScale.x,
            y: newPos.y * windowScale.y
        }
    }

    var getWindowScale = function () {
        // Fit to screen disabled for now.
        return {
            x:1,
            y:1
        }
        /*return {
            x: wickProject.width / window.innerWidth,
            y: wickProject.height / window.innerHeight
        }*/
    }

}</script>
<script>/* Wick - (c) 2017 Zach Rispoli, Luca Damasco, and Josh Rispoli */

/*  This file is part of Wick. 
    
    Wick is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Wick is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Wick.  If not, see <http://www.gnu.org/licenses/>. */
    
var WickPlayer = function () {

    var self = this;

    self.running = false;

    var initialStateProject;
    var stats;

    self.runProject = function (projectJSON) {

        if(localStorage.enableStats) {
            stats = new Stats();
            stats.showPanel(1);
            document.body.appendChild(stats.dom);
        }

        try {
            if(window.parent && window.parent.wickEditor) window.wickEditor = window.parent.wickEditor;
        } catch (e) {
            console.log(e)
        }

        self.running = true;

        self.canvasContainer = document.getElementById('playerCanvasContainer');

        resetElapsedTime();

        // Load the project!
        self.project = WickProject.fromJSON(projectJSON);
        initialStateProject = WickProject.fromJSON(projectJSON);

        self.canvasContainer.style.width = self.project.width+'px';
        self.canvasContainer.style.height = self.project.height+'px';
        self.canvasContainer.style.backgroundColor = self.project.backgroundColor;

        self.project.rootObject.generateObjectNameReferences(self.project.rootObject);
        initialStateProject.rootObject.generateObjectNameReferences(initialStateProject.rootObject);

        self.project.prepareForPlayer();
        initialStateProject.prepareForPlayer();

        // Make the camera
        window.camera = new WickCamera(self.project);

        // Setup renderer/input/audio player
        self.renderer = new WickPixiRenderer(self.canvasContainer);
        self.inputHandler = new WickPlayerInputHandler(self.canvasContainer, self.project);
        self.audioPlayer = new WickHowlerAudioPlayer(self.project);
        self.audioPlayer.reloadSoundsInProject(self.project);

        self.inputHandler.setup();

        self.project.loadFonts(function () {
            self.renderer.preloadAllAssets(self.project, function () {
                startUpdate();
            });
        });
    }

    window.runProject = function (projectJSON) {
        self.runProject(projectJSON)
    }

    self.stopRunningProject = function () {

        self.running = false;

        update();
        clearTimeout(loopTimeout);

        self.project = null;

        self.inputHandler.cleanup();
        self.audioPlayer.cleanup();
    }

    function startUpdate(fps) {
        then = Date.now();
        startTime = then;
        update(false);
    }

    var loopTimeout;
    var update = function (firstTick) {

        if(!self.running) return;

        if(stats) stats.begin();

        requestAnimationFrame(function() { update(false); });

        now = Date.now();
        elapsed = now - then;

        var fpsInterval = 1000/self.project.framerate;
        if (self.project.framerate === 60 || elapsed > fpsInterval) {
            then = now - (elapsed % fpsInterval);
            
            deleteObjects = [];
            if(!firstTick) {
                self.project.rootObject.generateObjectNameReferences()
                self.project.tick();
            }
            deleteObjects.forEach(function (d) {
                self.renderer.cleanupObjectTextures(d);
                d.remove();
                if(d.objectClonedFrom) {
                    var removeIndex = d.objectClonedFrom.clones.indexOf(d);
                    if(removeIndex !== -1) {
                        d.objectClonedFrom.clones.splice(removeIndex, 1);
                    }
                }
            });
            var activeObjs = self.project.rootObject.getAllActiveChildObjects();
            self.renderer.renderWickObjects(self.project, activeObjs, null, true);
            
            checkForSounds();

            self.inputHandler.update();
        }

        if(stats) stats.end();

    }

    function checkForSounds () {
        self.project.getAllFrames().forEach(function (frame) {
            if(frame._wantsToPlaySound) {
                self.audioPlayer.playSoundOnFrame(frame);
                frame._wantsToPlaySound = false;
            }
            if(frame._wantsToStopSound) {
                self.audioPlayer.stopSoundOnFrame(frame);
                frame._wantsToStopSound = false;
            }
        });
    }

    self.cloneObject = function (wickObj, args) {
        var clone = wickObj.copy();
        clone.name = undefined;
        clone.isClone = true;
        for(key in args) {
            clone[key] = args[key];
        }
        clone.asset = wickObj.asset;

        wickObj.clones.push(clone);

        clone.objectClonedFrom = wickObj;

        clone.prepareForPlayer()

        clone.parentObject = wickObj.parentObject;
        clone.parentFrame = wickObj.parentFrame;
        clone.parentObject.getCurrentLayer().getCurrentFrame().wickObjects.push(clone);
        clone.generateParentObjectReferences();

        return clone;
    }

    self.deleteObject = function (wickObj) {
        deleteObjects.push(wickObj);
        
    }

    self.resetStateOfObject = function (wickObject) {

        // Clones go away because they have no original state! :O
        if(wickObject.isClone) {
            self.deleteObject(wickObject)
            return;
        }

        var initialStateObject = initialStateProject.getObjectByUUID(wickObject.uuid);
        if(!initialStateObject) return;

        // TOXXXIC
        //console.log("-------------");
        var blacklist = ['_hitBox', 'asset', 'alphaMask', 'pixiSprite', 'pixiContainer', 'pixiText', 'audioData', 'wickScripts', 'parentObject', 'layers', '_active', '_wasActiveLastTick', '_scopeWrapper', 'parentFrame', 'bbox', 'tweens'];
        for (var name in wickObject) {
            if (name !== 'undefined' && wickObject.hasOwnProperty(name) && blacklist.indexOf(name) === -1) {
                if(initialStateObject[name] !== wickObject[name]) {
                    wickObject[name] = initialStateObject[name];
                }
            }
        }
        
        wickObject.hoveredOver = false;
        wickObject.playheadPosition = 0;
        wickObject._playing = true;

        // Don't forget to reset the childrens states
        if(wickObject.isSymbol) {
            wickObject.getAllChildObjects().forEach(function (child) {
                if(child.isSymbol)
                    wickPlayer.resetStateOfObject(child);
            });
        }

    }

}

// this is temporary, need a better system for this...
function runProject (json) {
    window.wickPlayer = new WickPlayer(); 
    window.wickPlayer.runProject(json);
}

function tryToLoadProjectFromWindowHash () {
    if(window.location.hash) {
        var projectPath = window.location.hash.slice(1); // remove first char (the hash)

        var xhr = new XMLHttpRequest();
        xhr.open('GET', projectPath, true);
        xhr.responseType = 'arraybuffer';

        xhr.onload = function(e) {
          if (this.status == 200) {
            var byteArray = new Uint8Array(this.response);
            var wickProjectJSON = LZString.decompressFromUint8Array(byteArray);
            runProject(wickProjectJSON);
          }
        };

        xhr.send();
    }
}
if(!window.WickEditor) tryToLoadProjectFromWindowHash();
</script>
<script src="project.js"></script>
